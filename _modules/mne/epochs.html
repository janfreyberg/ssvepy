<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>mne.epochs &#8212; ssvepy 0.2 documentation</title>
    
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/css/custom.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-3.3.6/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          ssvepy</a>
        <span class="navbar-text navbar-version pull-left"><b>0.2</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Install</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../example.html">Example Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
              
                
              
            
            
            
            
              <li class="hidden-sm"></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <h1>Source code for mne.epochs</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="sd">&quot;&quot;&quot;Tools for working with epoched data.&quot;&quot;&quot;</span>

<span class="c1"># Authors: Alexandre Gramfort &lt;alexandre.gramfort@telecom-paristech.fr&gt;</span>
<span class="c1">#          Matti Hamalainen &lt;msh@nmr.mgh.harvard.edu&gt;</span>
<span class="c1">#          Daniel Strohmeier &lt;daniel.strohmeier@tu-ilmenau.de&gt;</span>
<span class="c1">#          Denis Engemann &lt;denis.engemann@gmail.com&gt;</span>
<span class="c1">#          Mainak Jas &lt;mainak@neuro.hut.fi&gt;</span>
<span class="c1">#</span>
<span class="c1"># License: BSD (3-clause)</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="k">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">os.path</span> <span class="k">as</span> <span class="nn">op</span>
<span class="kn">from</span> <span class="nn">distutils.version</span> <span class="k">import</span> <span class="n">LooseVersion</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="k">import</span> <span class="n">Integral</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span>

<span class="kn">from</span> <span class="nn">.io.write</span> <span class="k">import</span> <span class="p">(</span><span class="n">start_file</span><span class="p">,</span> <span class="n">start_block</span><span class="p">,</span> <span class="n">end_file</span><span class="p">,</span> <span class="n">end_block</span><span class="p">,</span>
                       <span class="n">write_int</span><span class="p">,</span> <span class="n">write_float_matrix</span><span class="p">,</span> <span class="n">write_float</span><span class="p">,</span>
                       <span class="n">write_id</span><span class="p">,</span> <span class="n">write_string</span><span class="p">,</span> <span class="n">_get_split_size</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.io.meas_info</span> <span class="k">import</span> <span class="n">read_meas_info</span><span class="p">,</span> <span class="n">write_meas_info</span><span class="p">,</span> <span class="n">_merge_info</span>
<span class="kn">from</span> <span class="nn">.io.open</span> <span class="k">import</span> <span class="n">fiff_open</span><span class="p">,</span> <span class="n">_get_next_fname</span>
<span class="kn">from</span> <span class="nn">.io.tree</span> <span class="k">import</span> <span class="n">dir_tree_find</span>
<span class="kn">from</span> <span class="nn">.io.tag</span> <span class="k">import</span> <span class="n">read_tag</span><span class="p">,</span> <span class="n">read_tag_info</span>
<span class="kn">from</span> <span class="nn">.io.constants</span> <span class="k">import</span> <span class="n">FIFF</span>
<span class="kn">from</span> <span class="nn">.io.pick</span> <span class="k">import</span> <span class="p">(</span><span class="n">pick_types</span><span class="p">,</span> <span class="n">channel_indices_by_type</span><span class="p">,</span> <span class="n">channel_type</span><span class="p">,</span>
                      <span class="n">pick_channels</span><span class="p">,</span> <span class="n">pick_info</span><span class="p">,</span> <span class="n">_pick_data_channels</span><span class="p">,</span>
                      <span class="n">_pick_aux_channels</span><span class="p">,</span> <span class="n">_DATA_CH_TYPES_SPLIT</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.io.proj</span> <span class="k">import</span> <span class="n">setup_proj</span><span class="p">,</span> <span class="n">ProjMixin</span><span class="p">,</span> <span class="n">_proj_equal</span>
<span class="kn">from</span> <span class="nn">.io.base</span> <span class="k">import</span> <span class="n">BaseRaw</span><span class="p">,</span> <span class="n">ToDataFrameMixin</span><span class="p">,</span> <span class="n">TimeMixin</span>
<span class="kn">from</span> <span class="nn">.bem</span> <span class="k">import</span> <span class="n">_check_origin</span>
<span class="kn">from</span> <span class="nn">.evoked</span> <span class="k">import</span> <span class="n">EvokedArray</span><span class="p">,</span> <span class="n">_check_decim</span>
<span class="kn">from</span> <span class="nn">.baseline</span> <span class="k">import</span> <span class="n">rescale</span><span class="p">,</span> <span class="n">_log_rescale</span>
<span class="kn">from</span> <span class="nn">.channels.channels</span> <span class="k">import</span> <span class="p">(</span><span class="n">ContainsMixin</span><span class="p">,</span> <span class="n">UpdateChannelsMixin</span><span class="p">,</span>
                                <span class="n">SetChannelsMixin</span><span class="p">,</span> <span class="n">InterpolationMixin</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.filter</span> <span class="k">import</span> <span class="n">resample</span><span class="p">,</span> <span class="n">detrend</span><span class="p">,</span> <span class="n">FilterMixin</span>
<span class="kn">from</span> <span class="nn">.event</span> <span class="k">import</span> <span class="n">_read_events_fif</span><span class="p">,</span> <span class="n">make_fixed_length_events</span>
<span class="kn">from</span> <span class="nn">.fixes</span> <span class="k">import</span> <span class="n">_get_args</span>
<span class="kn">from</span> <span class="nn">.viz</span> <span class="k">import</span> <span class="p">(</span><span class="n">plot_epochs</span><span class="p">,</span> <span class="n">plot_epochs_psd</span><span class="p">,</span> <span class="n">plot_epochs_psd_topomap</span><span class="p">,</span>
                  <span class="n">plot_epochs_image</span><span class="p">,</span> <span class="n">plot_topo_image_epochs</span><span class="p">,</span> <span class="n">plot_drop_log</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="k">import</span> <span class="p">(</span><span class="n">check_fname</span><span class="p">,</span> <span class="n">logger</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">_check_type_picks</span><span class="p">,</span>
                    <span class="n">_time_mask</span><span class="p">,</span> <span class="n">check_random_state</span><span class="p">,</span> <span class="n">warn</span><span class="p">,</span> <span class="n">_pl</span><span class="p">,</span>
                    <span class="n">sizeof_fmt</span><span class="p">,</span> <span class="n">SizeMixin</span><span class="p">,</span> <span class="n">copy_function_doc_to_method_doc</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.externals.six</span> <span class="k">import</span> <span class="n">iteritems</span><span class="p">,</span> <span class="n">string_types</span>
<span class="kn">from</span> <span class="nn">.externals.six.moves</span> <span class="k">import</span> <span class="nb">zip</span>


<span class="k">def</span> <span class="nf">_save_split</span><span class="p">(</span><span class="n">epochs</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">part_idx</span><span class="p">,</span> <span class="n">n_parts</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Split epochs.&quot;&quot;&quot;</span>
    <span class="c1"># insert index in filename</span>
    <span class="n">path</span><span class="p">,</span> <span class="n">base</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">part_idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">-</span><span class="si">%d</span><span class="s1">.</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">base</span><span class="p">[:</span><span class="n">idx</span><span class="p">],</span> <span class="n">part_idx</span><span class="p">,</span>
                                            <span class="n">base</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]))</span>

    <span class="n">next_fname</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">part_idx</span> <span class="o">&lt;</span> <span class="n">n_parts</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">next_fname</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">-</span><span class="si">%d</span><span class="s1">.</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">base</span><span class="p">[:</span><span class="n">idx</span><span class="p">],</span> <span class="n">part_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                                 <span class="n">base</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]))</span>
        <span class="n">next_idx</span> <span class="o">=</span> <span class="n">part_idx</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">fid</span> <span class="o">=</span> <span class="n">start_file</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>

    <span class="n">info</span> <span class="o">=</span> <span class="n">epochs</span><span class="o">.</span><span class="n">info</span>
    <span class="n">meas_id</span> <span class="o">=</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;meas_id&#39;</span><span class="p">]</span>

    <span class="n">start_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_MEAS</span><span class="p">)</span>
    <span class="n">write_id</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_BLOCK_ID</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;meas_id&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">write_id</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_PARENT_BLOCK_ID</span><span class="p">,</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;meas_id&#39;</span><span class="p">])</span>

    <span class="c1"># Write measurement info</span>
    <span class="n">write_meas_info</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">info</span><span class="p">)</span>

    <span class="c1"># One or more evoked data sets</span>
    <span class="n">start_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_PROCESSED_DATA</span><span class="p">)</span>
    <span class="n">start_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_MNE_EPOCHS</span><span class="p">)</span>

    <span class="c1"># write events out after getting data to ensure bad events are dropped</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">epochs</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
    <span class="k">assert</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;float64&#39;</span>
    <span class="n">start_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_MNE_EVENTS</span><span class="p">)</span>
    <span class="n">write_int</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_MNE_EVENT_LIST</span><span class="p">,</span> <span class="n">epochs</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">mapping_</span> <span class="o">=</span> <span class="s1">&#39;;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">k</span> <span class="o">+</span> <span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span>
                         <span class="n">epochs</span><span class="o">.</span><span class="n">event_id</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
    <span class="n">write_string</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_DESCRIPTION</span><span class="p">,</span> <span class="n">mapping_</span><span class="p">)</span>
    <span class="n">end_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_MNE_EVENTS</span><span class="p">)</span>

    <span class="c1"># First and last sample</span>
    <span class="n">first</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">tmin</span> <span class="o">*</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]))</span>  <span class="c1"># round just to be safe</span>
    <span class="n">last</span> <span class="o">=</span> <span class="n">first</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">times</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">write_int</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_FIRST_SAMPLE</span><span class="p">,</span> <span class="n">first</span><span class="p">)</span>
    <span class="n">write_int</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_LAST_SAMPLE</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span>

    <span class="c1"># save baseline</span>
    <span class="k">if</span> <span class="n">epochs</span><span class="o">.</span><span class="n">baseline</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bmin</span><span class="p">,</span> <span class="n">bmax</span> <span class="o">=</span> <span class="n">epochs</span><span class="o">.</span><span class="n">baseline</span>
        <span class="n">bmin</span> <span class="o">=</span> <span class="n">epochs</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">bmin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">bmin</span>
        <span class="n">bmax</span> <span class="o">=</span> <span class="n">epochs</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">bmax</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">bmax</span>
        <span class="n">write_float</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_MNE_BASELINE_MIN</span><span class="p">,</span> <span class="n">bmin</span><span class="p">)</span>
        <span class="n">write_float</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_MNE_BASELINE_MAX</span><span class="p">,</span> <span class="n">bmax</span><span class="p">)</span>

    <span class="c1"># The epochs itself</span>
    <span class="n">decal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">]):</span>
        <span class="n">decal</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;cal&#39;</span><span class="p">]</span> <span class="o">*</span>
                          <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;scale&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>

    <span class="n">data</span> <span class="o">*=</span> <span class="n">decal</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="n">write_float_matrix</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_EPOCH</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="c1"># undo modifications to data</span>
    <span class="n">data</span> <span class="o">/=</span> <span class="n">decal</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="n">write_string</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_MNE_EPOCHS_DROP_LOG</span><span class="p">,</span>
                 <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">drop_log</span><span class="p">))</span>

    <span class="n">write_int</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_MNE_EPOCHS_SELECTION</span><span class="p">,</span>
              <span class="n">epochs</span><span class="o">.</span><span class="n">selection</span><span class="p">)</span>

    <span class="c1"># And now write the next file info in case epochs are split on disk</span>
    <span class="k">if</span> <span class="n">next_fname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">n_parts</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">start_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_REF</span><span class="p">)</span>
        <span class="n">write_int</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_REF_ROLE</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFV_ROLE_NEXT_FILE</span><span class="p">)</span>
        <span class="n">write_string</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_REF_FILE_NAME</span><span class="p">,</span> <span class="n">op</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">next_fname</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">meas_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">write_id</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_REF_FILE_ID</span><span class="p">,</span> <span class="n">meas_id</span><span class="p">)</span>
        <span class="n">write_int</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_REF_FILE_NUM</span><span class="p">,</span> <span class="n">next_idx</span><span class="p">)</span>
        <span class="n">end_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_REF</span><span class="p">)</span>

    <span class="n">end_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_MNE_EPOCHS</span><span class="p">)</span>
    <span class="n">end_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_PROCESSED_DATA</span><span class="p">)</span>
    <span class="n">end_block</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_MEAS</span><span class="p">)</span>
    <span class="n">end_file</span><span class="p">(</span><span class="n">fid</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">BaseEpochs</span><span class="p">(</span><span class="n">ProjMixin</span><span class="p">,</span> <span class="n">ContainsMixin</span><span class="p">,</span> <span class="n">UpdateChannelsMixin</span><span class="p">,</span>
                 <span class="n">SetChannelsMixin</span><span class="p">,</span> <span class="n">InterpolationMixin</span><span class="p">,</span> <span class="n">FilterMixin</span><span class="p">,</span>
                 <span class="n">ToDataFrameMixin</span><span class="p">,</span> <span class="n">TimeMixin</span><span class="p">,</span> <span class="n">SizeMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract base class for Epochs-type classes.</span>

<span class="sd">    This class provides basic functionality and should never be instantiated</span>
<span class="sd">    directly. See Epochs below for an explanation of the parameters.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    info : dict</span>
<span class="sd">        A copy of the info dict from the raw object.</span>
<span class="sd">    data : ndarray | None</span>
<span class="sd">        If ``None``, data will be read from the Raw object. If ndarray, must be</span>
<span class="sd">        of shape (n_epochs, n_channels, n_times).</span>
<span class="sd">    events : array of int, shape (n_events, 3)</span>
<span class="sd">        See `Epochs` docstring.</span>
<span class="sd">    event_id : int | list of int | dict | None</span>
<span class="sd">        See `Epochs` docstring.</span>
<span class="sd">    tmin : float</span>
<span class="sd">        See `Epochs` docstring.</span>
<span class="sd">    tmax : float</span>
<span class="sd">        See `Epochs` docstring.</span>
<span class="sd">    baseline : None or tuple of length 2 (default (None, 0))</span>
<span class="sd">        See `Epochs` docstring.</span>
<span class="sd">    raw : Raw object</span>
<span class="sd">        An instance of Raw.</span>
<span class="sd">    picks : array-like of int | None (default)</span>
<span class="sd">        See `Epochs` docstring.</span>
<span class="sd">    reject : dict | None</span>
<span class="sd">        See `Epochs` docstring.</span>
<span class="sd">    flat : dict | None</span>
<span class="sd">        See `Epochs` docstring.</span>
<span class="sd">    decim : int</span>
<span class="sd">        See `Epochs` docstring.</span>
<span class="sd">    reject_tmin : scalar | None</span>
<span class="sd">        See `Epochs` docstring.</span>
<span class="sd">    reject_tmax : scalar | None</span>
<span class="sd">        See `Epochs` docstring.</span>
<span class="sd">    detrend : int | None</span>
<span class="sd">        See `Epochs` docstring.</span>
<span class="sd">    proj : bool | &#39;delayed&#39;</span>
<span class="sd">        See `Epochs` docstring.</span>
<span class="sd">    on_missing : str</span>
<span class="sd">        See `Epochs` docstring.</span>
<span class="sd">    preload_at_end : bool</span>
<span class="sd">        Load all epochs from disk when creating the object</span>
<span class="sd">        or wait before accessing each epoch (more memory</span>
<span class="sd">        efficient but can be slower).</span>
<span class="sd">    selection : iterable | None</span>
<span class="sd">        Iterable of indices of selected epochs. If ``None``, will be</span>
<span class="sd">        automatically generated, corresponding to all non-zero events.</span>
<span class="sd">    drop_log : list | None</span>
<span class="sd">        List of lists of strings indicating which epochs have been marked to be</span>
<span class="sd">        ignored.</span>
<span class="sd">    filename : str | None</span>
<span class="sd">        The filename (if the epochs are read from disk).</span>
<span class="sd">    verbose : bool, str, int, or None</span>
<span class="sd">        If not None, override default verbose level (see :func:`mne.verbose`</span>
<span class="sd">        and :ref:`Logging documentation &lt;tut_logging&gt;` for more). Defaults to</span>
<span class="sd">        raw.verbose.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The `BaseEpochs` class is public to allow for stable type-checking in user</span>
<span class="sd">    code (i.e., ``isinstance(my_epochs, BaseEpochs)``) but should not be used</span>
<span class="sd">    as a constructor for Epochs objects (use instead `mne.Epochs`).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">event_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=-</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                 <span class="n">baseline</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">raw</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reject</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">flat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">reject_tmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reject_tmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">detrend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">on_missing</span><span class="o">=</span><span class="s1">&#39;error&#39;</span><span class="p">,</span>
                 <span class="n">preload_at_end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">selection</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">drop_log</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># noqa: D102</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="k">if</span> <span class="n">on_missing</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="s1">&#39;warning&#39;</span><span class="p">,</span> <span class="s1">&#39;ignore&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;on_missing must be one of: error, &#39;</span>
                             <span class="s1">&#39;warning, ignore. Got: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">on_missing</span><span class="p">)</span>

        <span class="c1"># check out event_id dict</span>
        <span class="k">if</span> <span class="n">event_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># convert to int to make typing-checks happy</span>
            <span class="n">event_id</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">events</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">event_id</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">event_id</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Event IDs must be of type integer&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">event_id</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Event names must be of type str&#39;</span><span class="p">)</span>
            <span class="n">event_id</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">event_id</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">event_id</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">event_id</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Event IDs must be of type integer&#39;</span><span class="p">)</span>
            <span class="n">event_id</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">event_id</span><span class="p">),</span> <span class="n">event_id</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">event_id</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">event_id</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">event_id</span><span class="p">):</span> <span class="n">event_id</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;event_id must be dict or int.&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">event_id</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">event_id</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>  <span class="c1"># make sure values are of type int</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">event_id</span> <span class="o">=</span> <span class="n">event_id</span>
        <span class="k">del</span> <span class="n">event_id</span>

        <span class="k">if</span> <span class="n">events</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># RtEpochs can have events=None</span>

            <span class="k">if</span> <span class="n">events</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;u&#39;</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;events must be an array of type int&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">events</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">events</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;events must be 2D with 3 columns&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_id</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">val</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">events</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;No matching events found for </span><span class="si">%s</span><span class="s1"> &#39;</span>
                           <span class="s1">&#39;(event id </span><span class="si">%i</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">on_missing</span> <span class="o">==</span> <span class="s1">&#39;error&#39;</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">on_missing</span> <span class="o">==</span> <span class="s1">&#39;warning&#39;</span><span class="p">:</span>
                        <span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>  <span class="c1"># on_missing == &#39;ignore&#39;:</span>
                        <span class="k">pass</span>

            <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event_id</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="n">selected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">events</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">values</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">selection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">selected</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="n">selection</span>
            <span class="k">if</span> <span class="n">drop_log</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">drop_log</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="k">else</span> <span class="p">[</span><span class="s1">&#39;IGNORED&#39;</span><span class="p">]</span>
                                 <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">))]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">drop_log</span> <span class="o">=</span> <span class="n">drop_log</span>
            <span class="n">events</span> <span class="o">=</span> <span class="n">events</span><span class="p">[</span><span class="n">selected</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">events</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Event time samples were not unique&#39;</span><span class="p">)</span>
            <span class="n">n_events</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n_events</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">events</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The events passed to the Epochs constructor are not &#39;</span>
                         <span class="s1">&#39;chronologically ordered.&#39;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">n_events</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1"> matching events found&#39;</span> <span class="o">%</span> <span class="n">n_events</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No desired events found.&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">events</span>
            <span class="k">del</span> <span class="n">events</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">drop_log</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="nb">int</span><span class="p">)</span>
            <span class="c1"># do not set self.events here, let subclass do it</span>

        <span class="c1"># check reject_tmin and reject_tmax</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">reject_tmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">reject_tmin</span> <span class="o">&lt;</span> <span class="n">tmin</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;reject_tmin needs to be None or &gt;= tmin&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">reject_tmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">reject_tmax</span> <span class="o">&gt;</span> <span class="n">tmax</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;reject_tmax needs to be None or &lt;= tmax&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">reject_tmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">reject_tmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">reject_tmin</span> <span class="o">&gt;=</span> <span class="n">reject_tmax</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;reject_tmin needs to be &lt; reject_tmax&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">detrend</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">detrend</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;detrend must be None, 0, or 1&#39;</span><span class="p">)</span>

        <span class="c1"># check that baseline is in available data</span>
        <span class="k">if</span> <span class="n">tmin</span> <span class="o">&gt;</span> <span class="n">tmax</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;tmin has to be less than or equal to tmax&#39;</span><span class="p">)</span>
        <span class="n">_check_baseline</span><span class="p">(</span><span class="n">baseline</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">])</span>
        <span class="n">_log_rescale</span><span class="p">(</span><span class="n">baseline</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">baseline</span> <span class="o">=</span> <span class="n">baseline</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reject_tmin</span> <span class="o">=</span> <span class="n">reject_tmin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reject_tmax</span> <span class="o">=</span> <span class="n">reject_tmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">detrend</span> <span class="o">=</span> <span class="n">detrend</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span> <span class="o">=</span> <span class="n">raw</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span>
        <span class="k">del</span> <span class="n">info</span>

        <span class="k">if</span> <span class="n">picks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">picks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">])))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">pick_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">picks</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">picks</span> <span class="o">=</span> <span class="n">_check_type_picks</span><span class="p">(</span><span class="n">picks</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">picks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Picks cannot be empty.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">preload</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">decim</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> \
                    <span class="nb">round</span><span class="p">((</span><span class="n">tmax</span> <span class="o">-</span> <span class="n">tmin</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;bad data shape&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">preload</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Handle times</span>
        <span class="n">sfreq</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">])</span>
        <span class="n">start_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">tmin</span> <span class="o">*</span> <span class="n">sfreq</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start_idx</span><span class="p">,</span>
                                    <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">tmax</span> <span class="o">*</span> <span class="n">sfreq</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">sfreq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_times</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decim</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decimate</span><span class="p">(</span><span class="n">decim</span><span class="p">)</span>

        <span class="c1"># setup epoch rejection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reject</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reject_setup</span><span class="p">(</span><span class="n">reject</span><span class="p">,</span> <span class="n">flat</span><span class="p">)</span>

        <span class="c1"># do the rest</span>
        <span class="n">valid_proj</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;delayed&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">proj</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_proj</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;&quot;proj&quot; must be one of </span><span class="si">%s</span><span class="s1">, not </span><span class="si">%s</span><span class="s1">&#39;</span>
                             <span class="o">%</span> <span class="p">(</span><span class="n">valid_proj</span><span class="p">,</span> <span class="n">proj</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">proj</span> <span class="o">==</span> <span class="s1">&#39;delayed&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_do_delayed_proj</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Entering delayed SSP mode.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_do_delayed_proj</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">activate</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_delayed_proj</span> <span class="k">else</span> <span class="n">proj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_projector</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">setup_proj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span>
                                                <span class="n">activate</span><span class="o">=</span><span class="n">activate</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">preload_at_end</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span> <span class="ow">is</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">load_data</span><span class="p">()</span>  <span class="c1"># this will do the projection</span>
        <span class="k">elif</span> <span class="n">proj</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_projector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># let&#39;s make sure we project if data was provided and proj</span>
            <span class="c1"># requested</span>
            <span class="c1"># we could do this with np.einsum, but iteration should be</span>
            <span class="c1"># more memory safe in most instances</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_projector</span><span class="p">,</span> <span class="n">epoch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">filename</span>

    <span class="k">def</span> <span class="nf">load_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load the data if not already preloaded.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        epochs : instance of Epochs</span>
<span class="sd">            The epochs object.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function operates in-place.</span>

<span class="sd">        .. versionadded:: 0.10.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_data</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">preload</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decim_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decim</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">decimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decim</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Decimate the epochs.</span>

<span class="sd">        .. note:: No filtering is performed. To avoid aliasing, ensure</span>
<span class="sd">                  your data are properly lowpassed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        decim : int</span>
<span class="sd">            The amount to decimate data.</span>
<span class="sd">        offset : int</span>
<span class="sd">            Apply an offset to where the decimation starts relative to the</span>
<span class="sd">            sample corresponding to t=0. The offset is in samples at the</span>
<span class="sd">            current sampling rate.</span>

<span class="sd">            .. versionadded:: 0.12</span>

<span class="sd">        verbose : bool, str, int, or None</span>
<span class="sd">            If not None, override default verbose level (see</span>
<span class="sd">            :func:`mne.verbose` and :ref:`Logging documentation &lt;tut_logging&gt;`</span>
<span class="sd">            for more).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        epochs : instance of Epochs</span>
<span class="sd">            The decimated Epochs object.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        mne.Evoked.decimate</span>
<span class="sd">        mne.Epochs.resample</span>
<span class="sd">        mne.io.Raw.resample</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Decimation can be done multiple times. For example,</span>
<span class="sd">        ``epochs.decimate(2).decimate(2)`` will be the same as</span>
<span class="sd">        ``epochs.decimate(4)``.</span>

<span class="sd">        .. versionadded:: 0.10.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">decim</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">new_sfreq</span> <span class="o">=</span> <span class="n">_check_decim</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">decim</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
        <span class="n">start_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span> <span class="o">*</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">_decim</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_decim</span> <span class="o">*=</span> <span class="n">decim</span>
        <span class="n">i_start</span> <span class="o">=</span> <span class="n">start_idx</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decim</span> <span class="o">+</span> <span class="n">offset</span>
        <span class="n">decim_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">i_start</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_sfreq</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">decim_slice</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_raw_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_times</span><span class="p">[</span><span class="n">decim_slice</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decim_slice</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decim</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_times</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_decim_slice</span> <span class="o">=</span> <span class="n">decim_slice</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_times</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_decim_slice</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">apply_baseline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">baseline</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Baseline correct epochs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        baseline : tuple of length 2</span>
<span class="sd">            The time interval to apply baseline correction. If None do not</span>
<span class="sd">            apply it. If baseline is (a, b) the interval is between &quot;a (s)&quot; and</span>
<span class="sd">            &quot;b (s)&quot;. If a is None the beginning of the data is used and if b is</span>
<span class="sd">            None then b is set to the end of the interval. If baseline is equal</span>
<span class="sd">            to (None, None) all the time interval is used. Correction is</span>
<span class="sd">            applied by computing mean of the baseline period and subtracting it</span>
<span class="sd">            from the data. The baseline (a, b) includes both endpoints, i.e.</span>
<span class="sd">            all timepoints t such that a &lt;= t &lt;= b.</span>
<span class="sd">        verbose : bool, str, int, or None</span>
<span class="sd">            If not None, override default verbose level (see</span>
<span class="sd">            :func:`mne.verbose` and :ref:`Logging documentation &lt;tut_logging&gt;`</span>
<span class="sd">            for more).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        epochs : instance of Epochs</span>
<span class="sd">            The baseline-corrected Epochs object.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Baseline correction can be done multiple times.</span>

<span class="sd">        .. versionadded:: 0.10.0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
            <span class="c1"># Eventually we can relax this restriction, but it will require</span>
            <span class="c1"># more careful checking of baseline (e.g., refactor with the</span>
            <span class="c1"># BaseEpochs.__init__ checks)</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Data must be loaded to apply a new baseline&#39;</span><span class="p">)</span>
        <span class="n">_check_baseline</span><span class="p">(</span><span class="n">baseline</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmax</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">])</span>

        <span class="n">picks</span> <span class="o">=</span> <span class="n">_pick_data_channels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[],</span> <span class="n">with_ref_meg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">picks_aux</span> <span class="o">=</span> <span class="n">_pick_aux_channels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[])</span>
        <span class="n">picks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">picks</span><span class="p">,</span> <span class="n">picks_aux</span><span class="p">)))</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">data</span><span class="p">[:,</span> <span class="n">picks</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">rescale</span><span class="p">(</span><span class="n">data</span><span class="p">[:,</span> <span class="n">picks</span><span class="p">,</span> <span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">baseline</span><span class="p">,</span>
                                    <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">baseline</span> <span class="o">=</span> <span class="n">baseline</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_reject_setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reject</span><span class="p">,</span> <span class="n">flat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Set self._reject_time and self._channel_type_idx.&quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">channel_indices_by_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>
        <span class="n">reject</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">reject</span><span class="p">)</span> <span class="k">if</span> <span class="n">reject</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">flat</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">flat</span><span class="p">)</span> <span class="k">if</span> <span class="n">flat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">rej</span><span class="p">,</span> <span class="n">kind</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">((</span><span class="n">reject</span><span class="p">,</span> <span class="n">flat</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;reject&#39;</span><span class="p">,</span> <span class="s1">&#39;flat&#39;</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rej</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;reject and flat must be dict or None, not </span><span class="si">%s</span><span class="s1">&#39;</span>
                                <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">rej</span><span class="p">))</span>
            <span class="n">bads</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">rej</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bads</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Unknown channel types found in </span><span class="si">%s</span><span class="s1">: </span><span class="si">%s</span><span class="s1">&#39;</span>
                               <span class="o">%</span> <span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">bads</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">idx</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># don&#39;t throw an error if rejection/flat would do nothing</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">reject</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span> <span class="ow">or</span>
                                       <span class="n">flat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
                <span class="c1"># This is where we could eventually add e.g.</span>
                <span class="c1"># self.allow_missing_reject_keys check to allow users to</span>
                <span class="c1"># provide keys that don&#39;t exist in data</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No </span><span class="si">%s</span><span class="s2"> channel found. Cannot reject based on &quot;</span>
                                 <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">key</span><span class="o">.</span><span class="n">upper</span><span class="p">()))</span>

        <span class="c1"># check for invalid values</span>
        <span class="k">for</span> <span class="n">rej</span><span class="p">,</span> <span class="n">kind</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">((</span><span class="n">reject</span><span class="p">,</span> <span class="n">flat</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;Rejection&#39;</span><span class="p">,</span> <span class="s1">&#39;Flat&#39;</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">rej</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> value must be a number &gt;= 0, not &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span>
                                     <span class="o">%</span> <span class="p">(</span><span class="n">kind</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>

        <span class="c1"># now check to see if our rejection and flat are getting more</span>
        <span class="c1"># restrictive</span>
        <span class="n">old_reject</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reject</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reject</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">old_flat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flat</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flat</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">bad_msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;</span><span class="si">{kind}</span><span class="s1">[&quot;</span><span class="si">{key}</span><span class="s1">&quot;] == </span><span class="si">{new}</span><span class="s1"> </span><span class="si">{op}</span><span class="s1"> </span><span class="si">{old}</span><span class="s1"> (old value), new &#39;</span>
                   <span class="s1">&#39;</span><span class="si">{kind}</span><span class="s1"> values must be at least as stringent as &#39;</span>
                   <span class="s1">&#39;previous ones&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">reject</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">old_reject</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">old</span> <span class="o">=</span> <span class="n">old_reject</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">reject</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new</span> <span class="o">&gt;</span> <span class="n">old</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">bad_msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;reject&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span>
                                                <span class="n">new</span><span class="o">=</span><span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="n">old</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="s1">&#39;&gt;&#39;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">flat</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">old_flat</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">old</span> <span class="o">=</span> <span class="n">old_flat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">flat</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">new</span> <span class="o">&lt;</span> <span class="n">old</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">bad_msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;flat&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span>
                                                <span class="n">new</span><span class="o">=</span><span class="n">new</span><span class="p">,</span> <span class="n">old</span><span class="o">=</span><span class="n">old</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="s1">&#39;&lt;&#39;</span><span class="p">))</span>

        <span class="c1"># after validation, set parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bad_dropped</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_channel_type_idx</span> <span class="o">=</span> <span class="n">idx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reject</span> <span class="o">=</span> <span class="n">reject</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reject</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="n">flat</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">flat</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reject_tmin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reject_tmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reject_time</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reject_tmin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">reject_imin</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reject_tmin</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">reject_imin</span> <span class="o">=</span> <span class="n">idxs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reject_tmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">reject_imax</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reject_tmax</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">reject_imax</span> <span class="o">=</span> <span class="n">idxs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reject_time</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">reject_imin</span><span class="p">,</span> <span class="n">reject_imax</span><span class="p">)</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">_is_good_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Determine if epoch is good.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="p">[</span><span class="n">data</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;NO_DATA&#39;</span><span class="p">]</span>
        <span class="n">n_times</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">n_times</span><span class="p">:</span>
            <span class="c1"># epoch is too short ie at the end of the data</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;TOO_SHORT&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reject</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">flat</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reject_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reject_time</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">_is_good</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_channel_type_idx</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">reject</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span> <span class="n">full_report</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">ignore_chs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;bads&#39;</span><span class="p">])</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">_detrend_offset_decim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Aux Function: detrend, baseline correct, offset, decim.</span>

<span class="sd">        Note: operates inplace</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">epoch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">epoch</span>

        <span class="c1"># Detrend</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">detrend</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">picks</span> <span class="o">=</span> <span class="n">_pick_data_channels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[])</span>
            <span class="n">epoch</span><span class="p">[</span><span class="n">picks</span><span class="p">]</span> <span class="o">=</span> <span class="n">detrend</span><span class="p">(</span><span class="n">epoch</span><span class="p">[</span><span class="n">picks</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">detrend</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Baseline correct</span>
        <span class="n">picks</span> <span class="o">=</span> <span class="n">pick_types</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">meg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">eeg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stim</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                           <span class="n">ref_meg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">eog</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ecg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">seeg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">emg</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bio</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ecog</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fnirs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">exclude</span><span class="o">=</span><span class="p">[])</span>
        <span class="n">epoch</span><span class="p">[</span><span class="n">picks</span><span class="p">]</span> <span class="o">=</span> <span class="n">rescale</span><span class="p">(</span><span class="n">epoch</span><span class="p">[</span><span class="n">picks</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_times</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">baseline</span><span class="p">,</span>
                               <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># handle offset</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">epoch</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span>

        <span class="c1"># Decimate if necessary (i.e., epoch not preloaded)</span>
        <span class="n">epoch</span> <span class="o">=</span> <span class="n">epoch</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_decim_slice</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">epoch</span>

    <span class="k">def</span> <span class="nf">iter_evoked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over epochs as a sequence of Evoked objects.</span>

<span class="sd">        The Evoked objects yielded will each contain a single epoch (i.e., no</span>
<span class="sd">        averaging is performed).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span>  <span class="c1"># properly signal the end of iteration</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">event_id</span> <span class="o">=</span> <span class="n">out</span>
            <span class="n">tmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">info</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>

            <span class="k">yield</span> <span class="n">EvokedArray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">event_id</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">subtract_evoked</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evoked</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Subtract an evoked response from each epoch.</span>

<span class="sd">        Can be used to exclude the evoked response when analyzing induced</span>
<span class="sd">        activity, see e.g. [1].</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        [1] David et al. &quot;Mechanisms of evoked and induced responses in</span>
<span class="sd">        MEG/EEG&quot;, NeuroImage, vol. 31, no. 4, pp. 1580-1591, July 2006.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        evoked : instance of Evoked | None</span>
<span class="sd">            The evoked response to subtract. If None, the evoked response</span>
<span class="sd">            is computed from Epochs itself.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : instance of Epochs</span>
<span class="sd">            The modified instance (instance is also modified inplace).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Subtracting Evoked from Epochs&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">evoked</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">picks</span> <span class="o">=</span> <span class="n">_pick_data_channels</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[])</span>
            <span class="n">evoked</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">picks</span><span class="p">)</span>

        <span class="c1"># find the indices of the channels to use</span>
        <span class="n">picks</span> <span class="o">=</span> <span class="n">pick_channels</span><span class="p">(</span><span class="n">evoked</span><span class="o">.</span><span class="n">ch_names</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">)</span>

        <span class="c1"># make sure the omitted channels are not data channels</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">picks</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">):</span>
            <span class="n">sel_ch</span> <span class="o">=</span> <span class="p">[</span><span class="n">evoked</span><span class="o">.</span><span class="n">ch_names</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">]</span>
            <span class="n">diff_ch</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">sel_ch</span><span class="p">))</span>
            <span class="n">diff_idx</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">diff_ch</span><span class="p">]</span>
            <span class="n">diff_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">channel_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">diff_idx</span><span class="p">]</span>
            <span class="n">bad_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">diff_types</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">diff_types</span> <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span>
                       <span class="n">_DATA_CH_TYPES_SPLIT</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bad_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">bad_str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">diff_ch</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">bad_idx</span><span class="p">])</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The following data channels are missing &#39;</span>
                                 <span class="s1">&#39;in the evoked response: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">bad_str</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;    The following channels are not included in the &#39;</span>
                        <span class="s1">&#39;subtraction: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">diff_ch</span><span class="p">))</span>

        <span class="c1"># make sure the times match</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">evoked</span><span class="o">.</span><span class="n">times</span><span class="p">)</span> <span class="ow">or</span>
                <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">-</span> <span class="n">evoked</span><span class="o">.</span><span class="n">times</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mf">1e-7</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Epochs and Evoked object do not contain &#39;</span>
                             <span class="s1">&#39;the same time points.&#39;</span><span class="p">)</span>

        <span class="c1"># handle SSPs</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj</span> <span class="ow">and</span> <span class="n">evoked</span><span class="o">.</span><span class="n">proj</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Evoked has SSP applied while Epochs has not.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">evoked</span><span class="o">.</span><span class="n">proj</span><span class="p">:</span>
            <span class="n">evoked</span> <span class="o">=</span> <span class="n">evoked</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">apply_proj</span><span class="p">()</span>

        <span class="c1"># find the indices of the channels to use in Epochs</span>
        <span class="n">ep_picks</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">evoked</span><span class="o">.</span><span class="n">ch_names</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">]</span>

        <span class="c1"># do the subtraction</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[:,</span> <span class="n">ep_picks</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-=</span> <span class="n">evoked</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">picks</span><span class="p">][</span><span class="kc">None</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)),</span>
                                        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_offset</span><span class="p">[</span><span class="n">ep_picks</span><span class="p">]</span> <span class="o">-=</span> <span class="n">evoked</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">picks</span><span class="p">]</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;[done]&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Provide a wrapper for Py3k.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">average</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute average of epochs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        picks : array-like of int | None</span>
<span class="sd">            If None only MEG, EEG, SEEG, ECoG, and fNIRS channels are kept</span>
<span class="sd">            otherwise the channels indices in picks are kept.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        evoked : instance of Evoked</span>
<span class="sd">            The averaged epochs.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Computes an average of all epochs in the instance, even if</span>
<span class="sd">        they correspond to different conditions. To average by condition,</span>
<span class="sd">        do ``epochs[condition].average()`` for each condition separately.</span>

<span class="sd">        When picks is None and epochs contain only ICA channels, no channels</span>
<span class="sd">        are selected, resulting in an error. This is because ICA channels</span>
<span class="sd">        are not considered data channels (they are of misc type) and only data</span>
<span class="sd">        channels are selected when picks is None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_mean_or_stderr</span><span class="p">(</span><span class="n">picks</span><span class="p">,</span> <span class="s1">&#39;ave&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">standard_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute standard error over epochs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        picks : array-like of int | None</span>
<span class="sd">            If None only MEG, EEG, SEEG, ECoG, and fNIRS channels are kept</span>
<span class="sd">            otherwise the channels indices in picks are kept.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        evoked : instance of Evoked</span>
<span class="sd">            The standard error over epochs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_mean_or_stderr</span><span class="p">(</span><span class="n">picks</span><span class="p">,</span> <span class="s1">&#39;stderr&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_compute_mean_or_stderr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">picks</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;ave&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Compute the mean or std over epochs and return Evoked.&quot;&quot;&quot;</span>
        <span class="n">_do_std</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;stderr&#39;</span> <span class="k">else</span> <span class="kc">False</span>

        <span class="c1"># if instance contains ICA channels they won&#39;t be included unless picks</span>
        <span class="c1"># is specified</span>
        <span class="k">if</span> <span class="n">picks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_ICA</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;ICA&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">check_ICA</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;picks must be specified (i.e. not None) for &#39;</span>
                                <span class="s1">&#39;ICA channel data&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">check_ICA</span><span class="p">):</span>
                <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;ICA channels will not be included unless explicitly &#39;</span>
                     <span class="s1">&#39;selected in picks&#39;</span><span class="p">)</span>

        <span class="n">n_channels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">)</span>
        <span class="n">n_times</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
            <span class="n">n_events</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">)</span>
            <span class="n">fun</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span> <span class="k">if</span> <span class="n">_do_std</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">fun</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_channels</span><span class="p">,</span> <span class="n">n_times</span><span class="p">))</span>
            <span class="n">n_events</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">+=</span> <span class="n">e</span>
                <span class="n">n_events</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">n_events</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">/=</span> <span class="n">n_events</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

            <span class="c1"># convert to stderr if requested, could do in one pass but do in</span>
            <span class="c1"># two (slower) in case there are large numbers</span>
            <span class="k">if</span> <span class="n">_do_std</span><span class="p">:</span>
                <span class="n">data_mean</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">data</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">+=</span> <span class="p">(</span><span class="n">e</span> <span class="o">-</span> <span class="n">data_mean</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">data</span> <span class="o">/</span> <span class="n">n_events</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_do_std</span><span class="p">:</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;average&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="s1">&#39;standard_error&#39;</span>
            <span class="n">data</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">n_events</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evoked_from_epoch_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">picks</span><span class="p">,</span> <span class="n">n_events</span><span class="p">,</span>
                                            <span class="n">kind</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Give a nice string representation based on event ids.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event_id</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">comment</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event_id</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">comments</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_id</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%.2f</span><span class="s1"> * </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">count</span><span class="p">[</span><span class="n">value</span><span class="p">])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">),</span> <span class="n">key</span><span class="p">))</span>
            <span class="n">comment</span> <span class="o">=</span> <span class="s1">&#39; + &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">comments</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">comment</span>

    <span class="k">def</span> <span class="nf">_evoked_from_epoch_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">picks</span><span class="p">,</span> <span class="n">n_events</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span>
                                <span class="n">comment</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Create an evoked object from epoch data.&quot;&quot;&quot;</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
        <span class="n">evoked</span> <span class="o">=</span> <span class="n">EvokedArray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">comment</span><span class="o">=</span><span class="n">comment</span><span class="p">,</span>
                             <span class="n">nave</span><span class="o">=</span><span class="n">n_events</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">verbose</span><span class="p">)</span>
        <span class="c1"># XXX: above constructor doesn&#39;t recreate the times object precisely</span>
        <span class="n">evoked</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># pick channels</span>
        <span class="k">if</span> <span class="n">picks</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">picks</span> <span class="o">=</span> <span class="n">_pick_data_channels</span><span class="p">(</span><span class="n">evoked</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="p">[])</span>

        <span class="n">ch_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">evoked</span><span class="o">.</span><span class="n">ch_names</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">picks</span><span class="p">]</span>
        <span class="n">evoked</span><span class="o">.</span><span class="n">pick_channels</span><span class="p">(</span><span class="n">ch_names</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">evoked</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No data channel found when averaging.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">evoked</span><span class="o">.</span><span class="n">nave</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;evoked object is empty (based on less than 1 epoch)&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">evoked</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ch_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Channel names.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">]</span>

    <span class="nd">@copy_function_doc_to_method_doc</span><span class="p">(</span><span class="n">plot_epochs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scalings</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_epochs</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">n_channels</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span>
             <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">events</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">event_colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">block</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">plot_epochs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="n">picks</span><span class="p">,</span> <span class="n">scalings</span><span class="o">=</span><span class="n">scalings</span><span class="p">,</span>
                           <span class="n">n_epochs</span><span class="o">=</span><span class="n">n_epochs</span><span class="p">,</span> <span class="n">n_channels</span><span class="o">=</span><span class="n">n_channels</span><span class="p">,</span>
                           <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">events</span><span class="o">=</span><span class="n">events</span><span class="p">,</span>
                           <span class="n">event_colors</span><span class="o">=</span><span class="n">event_colors</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">block</span><span class="p">)</span>

    <span class="nd">@copy_function_doc_to_method_doc</span><span class="p">(</span><span class="n">plot_epochs_psd</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">plot_psd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fmax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">bandwidth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">adaptive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">low_bias</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">normalization</span><span class="o">=</span><span class="s1">&#39;length&#39;</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span>
                 <span class="n">area_mode</span><span class="o">=</span><span class="s1">&#39;std&#39;</span><span class="p">,</span> <span class="n">area_alpha</span><span class="o">=</span><span class="mf">0.33</span><span class="p">,</span> <span class="n">dB</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">plot_epochs_psd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span> <span class="n">fmax</span><span class="o">=</span><span class="n">fmax</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="n">tmin</span><span class="p">,</span>
                               <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="n">proj</span><span class="p">,</span> <span class="n">bandwidth</span><span class="o">=</span><span class="n">bandwidth</span><span class="p">,</span>
                               <span class="n">adaptive</span><span class="o">=</span><span class="n">adaptive</span><span class="p">,</span> <span class="n">low_bias</span><span class="o">=</span><span class="n">low_bias</span><span class="p">,</span>
                               <span class="n">normalization</span><span class="o">=</span><span class="n">normalization</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="n">picks</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
                               <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">area_mode</span><span class="o">=</span><span class="n">area_mode</span><span class="p">,</span>
                               <span class="n">area_alpha</span><span class="o">=</span><span class="n">area_alpha</span><span class="p">,</span> <span class="n">dB</span><span class="o">=</span><span class="n">dB</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
                               <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="nd">@copy_function_doc_to_method_doc</span><span class="p">(</span><span class="n">plot_epochs_psd_topomap</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">plot_psd_topomap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">tmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bandwidth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">adaptive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                         <span class="n">low_bias</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">normalization</span><span class="o">=</span><span class="s1">&#39;length&#39;</span><span class="p">,</span> <span class="n">ch_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">layout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;RdBu_r&#39;</span><span class="p">,</span> <span class="n">agg_fun</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dB</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                         <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cbar_fmt</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%0.3f</span><span class="s1">&#39;</span><span class="p">,</span>
                         <span class="n">outlines</span><span class="o">=</span><span class="s1">&#39;head&#39;</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">plot_epochs_psd_topomap</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">bands</span><span class="o">=</span><span class="n">bands</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="n">tmax</span><span class="p">,</span>
            <span class="n">proj</span><span class="o">=</span><span class="n">proj</span><span class="p">,</span> <span class="n">bandwidth</span><span class="o">=</span><span class="n">bandwidth</span><span class="p">,</span> <span class="n">adaptive</span><span class="o">=</span><span class="n">adaptive</span><span class="p">,</span>
            <span class="n">low_bias</span><span class="o">=</span><span class="n">low_bias</span><span class="p">,</span> <span class="n">normalization</span><span class="o">=</span><span class="n">normalization</span><span class="p">,</span> <span class="n">ch_type</span><span class="o">=</span><span class="n">ch_type</span><span class="p">,</span>
            <span class="n">layout</span><span class="o">=</span><span class="n">layout</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">agg_fun</span><span class="o">=</span><span class="n">agg_fun</span><span class="p">,</span> <span class="n">dB</span><span class="o">=</span><span class="n">dB</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">,</span>
            <span class="n">normalize</span><span class="o">=</span><span class="n">normalize</span><span class="p">,</span> <span class="n">cbar_fmt</span><span class="o">=</span><span class="n">cbar_fmt</span><span class="p">,</span> <span class="n">outlines</span><span class="o">=</span><span class="n">outlines</span><span class="p">,</span>
            <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="nd">@copy_function_doc_to_method_doc</span><span class="p">(</span><span class="n">plot_topo_image_epochs</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">plot_topo_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">colorbar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;RdBu_r&#39;</span><span class="p">,</span>
                        <span class="n">layout_scale</span><span class="o">=.</span><span class="mi">95</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scalings</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">border</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">fig_facecolor</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">fig_background</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">font_color</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">plot_topo_image_epochs</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="n">layout</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span>
            <span class="n">colorbar</span><span class="o">=</span><span class="n">colorbar</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
            <span class="n">layout_scale</span><span class="o">=</span><span class="n">layout_scale</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span> <span class="n">scalings</span><span class="o">=</span><span class="n">scalings</span><span class="p">,</span>
            <span class="n">border</span><span class="o">=</span><span class="n">border</span><span class="p">,</span> <span class="n">fig_facecolor</span><span class="o">=</span><span class="n">fig_facecolor</span><span class="p">,</span>
            <span class="n">fig_background</span><span class="o">=</span><span class="n">fig_background</span><span class="p">,</span> <span class="n">font_color</span><span class="o">=</span><span class="n">font_color</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">)</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">drop_bad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reject</span><span class="o">=</span><span class="s1">&#39;existing&#39;</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="s1">&#39;existing&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Drop bad epochs without retaining the epochs data.</span>

<span class="sd">        Should be used before slicing operations.</span>

<span class="sd">        .. warning:: This operation is slow since all epochs have to be read</span>
<span class="sd">                     from disk. To avoid reading epochs from disk multiple</span>
<span class="sd">                     times, use :func:`mne.Epochs.load_data()`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reject : dict | str | None</span>
<span class="sd">            Rejection parameters based on peak-to-peak amplitude.</span>
<span class="sd">            Valid keys are &#39;grad&#39; | &#39;mag&#39; | &#39;eeg&#39; | &#39;eog&#39; | &#39;ecg&#39;.</span>
<span class="sd">            If reject is None then no rejection is done. If &#39;existing&#39;,</span>
<span class="sd">            then the rejection parameters set at instantiation are used.</span>
<span class="sd">        flat : dict | str | None</span>
<span class="sd">            Rejection parameters based on flatness of signal.</span>
<span class="sd">            Valid keys are &#39;grad&#39; | &#39;mag&#39; | &#39;eeg&#39; | &#39;eog&#39; | &#39;ecg&#39;, and values</span>
<span class="sd">            are floats that set the minimum acceptable peak-to-peak amplitude.</span>
<span class="sd">            If flat is None then no rejection is done. If &#39;existing&#39;,</span>
<span class="sd">            then the flat parameters set at instantiation are used.</span>
<span class="sd">        verbose : bool, str, int, or None</span>
<span class="sd">            If not None, override default verbose level (see</span>
<span class="sd">            :func:`mne.verbose` and :ref:`Logging documentation &lt;tut_logging&gt;`</span>
<span class="sd">            for more). Defaults to self.verbose.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        epochs : instance of Epochs</span>
<span class="sd">            The epochs with bad epochs dropped. Operates in-place.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Dropping bad epochs can be done multiple times with different</span>
<span class="sd">        ``reject`` and ``flat`` parameters. However, once an epoch is</span>
<span class="sd">        dropped, it is dropped forever, so if more lenient thresholds may</span>
<span class="sd">        subsequently be applied, `epochs.copy` should be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">reject</span> <span class="o">==</span> <span class="s1">&#39;existing&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">flat</span> <span class="o">==</span> <span class="s1">&#39;existing&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_dropped</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">reject</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reject</span>
        <span class="k">if</span> <span class="n">flat</span> <span class="o">==</span> <span class="s1">&#39;existing&#39;</span><span class="p">:</span>
            <span class="n">flat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flat</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">rej</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="ow">and</span> <span class="n">rej</span> <span class="o">!=</span> <span class="s1">&#39;existing&#39;</span> <span class="k">for</span>
               <span class="n">rej</span> <span class="ow">in</span> <span class="p">(</span><span class="n">reject</span><span class="p">,</span> <span class="n">flat</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;reject and flat, if strings, must be &quot;existing&quot;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reject_setup</span><span class="p">(</span><span class="n">reject</span><span class="p">,</span> <span class="n">flat</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_get_data</span><span class="p">(</span><span class="n">out</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">drop_log_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;IGNORED&#39;</span><span class="p">,)):</span>
        <span class="sd">&quot;&quot;&quot;Compute the channel stats based on a drop_log from Epochs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ignore : list</span>
<span class="sd">            The drop reasons to ignore.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        perc : float</span>
<span class="sd">            Total percentage of epochs dropped.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        plot_drop_log</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_drop_log_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drop_log</span><span class="p">,</span> <span class="n">ignore</span><span class="p">)</span>

    <span class="nd">@copy_function_doc_to_method_doc</span><span class="p">(</span><span class="n">plot_drop_log</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">plot_drop_log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_max_plot</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">subject</span><span class="o">=</span><span class="s1">&#39;Unknown&#39;</span><span class="p">,</span>
                      <span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;IGNORED&#39;</span><span class="p">,),</span>
                      <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_dropped</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You cannot use plot_drop_log since bad &quot;</span>
                             <span class="s2">&quot;epochs have not yet been dropped. &quot;</span>
                             <span class="s2">&quot;Use epochs.drop_bad().&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">plot_drop_log</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">drop_log</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">n_max_plot</span><span class="p">,</span> <span class="n">subject</span><span class="p">,</span>
                             <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="n">ignore</span><span class="p">,</span>
                             <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">)</span>

    <span class="nd">@copy_function_doc_to_method_doc</span><span class="p">(</span><span class="n">plot_epochs_image</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">plot_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">colorbar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="n">units</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">scalings</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;RdBu_r&#39;</span><span class="p">,</span>
                   <span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overlay_times</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">plot_epochs_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="n">picks</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span>
                                 <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span> <span class="n">colorbar</span><span class="o">=</span><span class="n">colorbar</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span>
                                 <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="n">units</span><span class="p">,</span> <span class="n">scalings</span><span class="o">=</span><span class="n">scalings</span><span class="p">,</span>
                                 <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="n">fig</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span>
                                 <span class="n">overlay_times</span><span class="o">=</span><span class="n">overlay_times</span><span class="p">)</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;USER&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Drop epochs based on indices or boolean mask.</span>

<span class="sd">        .. note:: The indices refer to the current set of undropped epochs</span>
<span class="sd">                  rather than the complete set of dropped and undropped epochs.</span>
<span class="sd">                  They are therefore not necessarily consistent with any</span>
<span class="sd">                  external indices (e.g., behavioral logs). To drop epochs</span>
<span class="sd">                  based on external criteria, do not use the ``preload=True``</span>
<span class="sd">                  flag when constructing an Epochs object, and call this</span>
<span class="sd">                  method before calling the :func:`mne.Epochs.drop_bad` or</span>
<span class="sd">                  :func:`mne.Epochs.load_data` methods.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : array of ints or bools</span>
<span class="sd">            Set epochs to remove by specifying indices to remove or a boolean</span>
<span class="sd">            mask to apply (where True values get removed). Events are</span>
<span class="sd">            correspondingly modified.</span>
<span class="sd">        reason : str</span>
<span class="sd">            Reason for dropping the epochs (&#39;ECG&#39;, &#39;timeout&#39;, &#39;blink&#39; etc).</span>
<span class="sd">            Default: &#39;USER&#39;.</span>
<span class="sd">        verbose : bool, str, int, or None</span>
<span class="sd">            If not None, override default verbose level (see</span>
<span class="sd">            :func:`mne.verbose` and :ref:`Logging documentation &lt;tut_logging&gt;`</span>
<span class="sd">            for more). Defaults to self.verbose.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        epochs : instance of Epochs</span>
<span class="sd">            The epochs with indices dropped. Operates in-place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;indices must be a scalar or a 1-d array&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">indices</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">out_of_bounds</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">indices</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">out_of_bounds</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">out_of_bounds</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Epoch index </span><span class="si">%d</span><span class="s2"> is out of bounds&quot;</span> <span class="o">%</span> <span class="n">first</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">drop_log</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">[</span><span class="n">ii</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reason</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Dropped </span><span class="si">%d</span><span class="s1"> epoch</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">_pl</span><span class="p">(</span><span class="n">count</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">_get_epoch_from_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get a given epoch from disk.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_project_epoch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">epoch</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Process a raw epoch based on the delayed param.&quot;&quot;&quot;</span>
        <span class="c1"># whenever requested, the first epoch is being projected.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">epoch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">epoch</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="c1"># can happen if t &lt; 0 or reject based on annotations</span>
            <span class="k">return</span> <span class="n">epoch</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_delayed_proj</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_projector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">proj</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">epoch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_projector</span><span class="p">,</span> <span class="n">epoch</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">epoch</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">_get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load all data, dropping bad epochs along the way.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        out : bool</span>
<span class="sd">            Return the data. Setting this to False is used to reject bad</span>
<span class="sd">            epochs without caching all the data, which saves memory.</span>
<span class="sd">        verbose : bool, str, int, or None</span>
<span class="sd">            If not None, override default verbose level (see</span>
<span class="sd">            :func:`mne.verbose` and :ref:`Logging documentation &lt;tut_logging&gt;`</span>
<span class="sd">            for more). Defaults to self.verbose.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_events</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">)</span>
        <span class="c1"># in case there are no good events</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
            <span class="c1"># we will store our result in our existing array</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># we start out with an empty array, allocate only if necessary</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)))</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Loading data for </span><span class="si">%s</span><span class="s1"> events and </span><span class="si">%s</span><span class="s1"> original time &#39;</span>
                        <span class="s1">&#39;points ...&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n_events</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_times</span><span class="p">)))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_dropped</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">out</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">data</span>

            <span class="c1"># we need to load from disk, drop, and return data</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_events</span><span class="p">):</span>
                <span class="c1"># faster to pre-allocate memory here</span>
                <span class="n">epoch_noproj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_epoch_from_raw</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="n">epoch_noproj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detrend_offset_decim</span><span class="p">(</span><span class="n">epoch_noproj</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_delayed_proj</span><span class="p">:</span>
                    <span class="n">epoch_out</span> <span class="o">=</span> <span class="n">epoch_noproj</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">epoch_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_project_epoch</span><span class="p">(</span><span class="n">epoch_noproj</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_events</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ch_names</span><span class="p">),</span>
                                     <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">epoch_out</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">epoch_out</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># bads need to be dropped, this might occur after a preload</span>
            <span class="c1"># e.g., when calling drop_bad w/new params</span>
            <span class="n">good_idx</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">n_out</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">assert</span> <span class="n">n_events</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">sel</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>  <span class="c1"># from memory</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_delayed_proj</span><span class="p">:</span>
                        <span class="n">epoch_noproj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                        <span class="n">epoch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_project_epoch</span><span class="p">(</span><span class="n">epoch_noproj</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">epoch_noproj</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="n">epoch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># from disk</span>
                    <span class="n">epoch_noproj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_epoch_from_raw</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                    <span class="n">epoch_noproj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detrend_offset_decim</span><span class="p">(</span><span class="n">epoch_noproj</span><span class="p">)</span>
                    <span class="n">epoch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_project_epoch</span><span class="p">(</span><span class="n">epoch_noproj</span><span class="p">)</span>

                <span class="n">epoch_out</span> <span class="o">=</span> <span class="n">epoch_noproj</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_delayed_proj</span> <span class="k">else</span> <span class="n">epoch</span>
                <span class="n">is_good</span><span class="p">,</span> <span class="n">offending_reason</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_good_epoch</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">is_good</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">drop_log</span><span class="p">[</span><span class="n">sel</span><span class="p">]</span> <span class="o">+=</span> <span class="n">offending_reason</span>
                    <span class="k">continue</span>
                <span class="n">good_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

                <span class="c1"># store the epoch if there is a reason to (output or update)</span>
                <span class="k">if</span> <span class="n">out</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
                    <span class="c1"># faster to pre-allocate, then trim as necessary</span>
                    <span class="k">if</span> <span class="n">n_out</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
                        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">n_events</span><span class="p">,</span> <span class="n">epoch_out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                         <span class="n">epoch_out</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                        <span class="n">dtype</span><span class="o">=</span><span class="n">epoch_out</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">n_out</span><span class="p">]</span> <span class="o">=</span> <span class="n">epoch_out</span>
                    <span class="n">n_out</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_bad_dropped</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%d</span><span class="s2"> bad epochs dropped&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n_events</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">good_idx</span><span class="p">)))</span>

            <span class="c1"># Now update our properties</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">good_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># silly fix for old numpy index error</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="nb">int</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selection</span><span class="p">[</span><span class="n">good_idx</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">good_idx</span><span class="p">])</span>

            <span class="c1"># adjust the data size if there is a reason to (output or update)</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
                <span class="n">data</span><span class="o">.</span><span class="n">resize</span><span class="p">((</span><span class="n">n_out</span><span class="p">,)</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">refcheck</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span> <span class="k">if</span> <span class="n">out</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get all epochs as a 3D array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : array of shape (n_epochs, n_channels, n_times)</span>
<span class="sd">            A view on epochs data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_data</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the number of epochs.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n_epochs : int</span>
<span class="sd">            The number of remaining epochs.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function only works if bad epochs have been dropped.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        This can be used as::</span>

<span class="sd">            &gt;&gt;&gt; epochs.drop_bad()  # doctest: +SKIP</span>
<span class="sd">            &gt;&gt;&gt; len(epochs)  # doctest: +SKIP</span>
<span class="sd">            43</span>
<span class="sd">            &gt;&gt;&gt; len(epochs.events)  # doctest: +SKIP</span>
<span class="sd">            43</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_dropped</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Since bad epochs have not been dropped, the &#39;</span>
                               <span class="s1">&#39;length of the Epochs is not known. Load the &#39;</span>
                               <span class="s1">&#39;Epochs with preload=True, or call &#39;</span>
                               <span class="s1">&#39;Epochs.drop_bad(). To find the number &#39;</span>
                               <span class="s1">&#39;of events in the Epochs, use &#39;</span>
                               <span class="s1">&#39;len(Epochs.events).&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Facilitate iteration over epochs.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This enables the use of this Python pattern::</span>

<span class="sd">            &gt;&gt;&gt; for epoch in epochs:  # doctest: +SKIP</span>
<span class="sd">            &gt;&gt;&gt;     print(epoch)  # doctest: +SKIP</span>

<span class="sd">        Where ``epoch`` is given by successive outputs of</span>
<span class="sd">        :func:`mne.Epochs.next`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_current</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">yield</span> <span class="n">x</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_event_id</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over epoch data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        return_event_id : bool</span>
<span class="sd">            If True, return both the epoch data and an event_id.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        epoch : array of shape (n_channels, n_times)</span>
<span class="sd">            The epoch data.</span>
<span class="sd">        event_id : int</span>
<span class="sd">            The event id. Only returned if ``return_event_id`` is ``True``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">):</span>
                <span class="k">return</span>  <span class="c1"># signal the end</span>
            <span class="n">epoch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_current</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_current</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_good</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">is_good</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_current</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">):</span>
                    <span class="k">return</span>  <span class="c1"># signal the end properly</span>
                <span class="n">epoch_noproj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_epoch_from_raw</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_current</span><span class="p">)</span>
                <span class="n">epoch_noproj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_detrend_offset_decim</span><span class="p">(</span><span class="n">epoch_noproj</span><span class="p">)</span>
                <span class="n">epoch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_project_epoch</span><span class="p">(</span><span class="n">epoch_noproj</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_current</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">is_good</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_good_epoch</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span>
            <span class="c1"># If delayed-ssp mode, pass &#39;virgin&#39; data after rejection decision.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_delayed_proj</span><span class="p">:</span>
                <span class="n">epoch</span> <span class="o">=</span> <span class="n">epoch_noproj</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_event_id</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">epoch</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">epoch</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_current</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">epoch</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">return_event_id</span> <span class="k">else</span> <span class="n">epoch</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_id</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tmin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;First time point.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">filename</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The filename.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filename</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tmax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Last time point.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Build string representation.&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s1">&#39;n_events : </span><span class="si">%s</span><span class="s1"> &#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;(all good)&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_dropped</span> <span class="k">else</span> <span class="s1">&#39;(good &amp; bad)&#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, tmin : </span><span class="si">%s</span><span class="s1"> (s)&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, tmax : </span><span class="si">%s</span><span class="s1"> (s)&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmax</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, baseline : </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">baseline</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, ~</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sizeof_fmt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_size</span><span class="p">),)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;, data</span><span class="si">%s</span><span class="s1"> loaded&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span> <span class="k">else</span> <span class="s1">&#39; not&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event_id</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">%r</span><span class="s1">: </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span><span class="p">))</span>
                      <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event_id</span><span class="o">.</span><span class="n">items</span><span class="p">())]</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">counts</span><span class="p">)</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="s1">&#39;Epochs&#39;</span> <span class="k">if</span> <span class="n">class_name</span> <span class="o">==</span> <span class="s1">&#39;BaseEpochs&#39;</span> <span class="k">else</span> <span class="n">class_name</span>
        <span class="k">return</span> <span class="s1">&#39;&lt;</span><span class="si">%s</span><span class="s1">  |  </span><span class="si">%s</span><span class="s1">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">class_name</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_keys_to_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Find entries in event dict.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_id</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                         <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">_hid_match</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event_id</span><span class="p">,</span> <span class="n">keys</span><span class="p">)])</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an Epochs object with a copied subset of epochs.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        item : slice, array-like, str, or list</span>
<span class="sd">            See below for use cases.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        epochs : instance of Epochs</span>
<span class="sd">            See below for use cases.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Epochs can be accessed as ``epochs[...]`` in several ways:</span>

<span class="sd">            1. ``epochs[idx]``: Return ``Epochs`` object with a subset of</span>
<span class="sd">               epochs (supports single index and python-style slicing).</span>

<span class="sd">            2. ``epochs[&#39;name&#39;]``: Return ``Epochs`` object with a copy of the</span>
<span class="sd">               subset of epochs corresponding to an experimental condition as</span>
<span class="sd">               specified by &#39;name&#39;.</span>

<span class="sd">               If conditions are tagged by names separated by &#39;/&#39; (e.g.</span>
<span class="sd">               &#39;audio/left&#39;, &#39;audio/right&#39;), and &#39;name&#39; is not in itself an</span>
<span class="sd">               event key, this selects every event whose condition contains</span>
<span class="sd">               the &#39;name&#39; tag (e.g., &#39;left&#39; matches &#39;audio/left&#39; and</span>
<span class="sd">               &#39;visual/left&#39;; but not &#39;audio_left&#39;). Note that tags like</span>
<span class="sd">               &#39;auditory/left&#39; and &#39;left/auditory&#39; will be treated the</span>
<span class="sd">               same way when accessed using tags.</span>

<span class="sd">            3. ``epochs[[&#39;name_1&#39;, &#39;name_2&#39;, ... ]]``: Return ``Epochs`` object</span>
<span class="sd">               with a copy of the subset of epochs corresponding to multiple</span>
<span class="sd">               experimental conditions as specified by</span>
<span class="sd">               ``&#39;name_1&#39;, &#39;name_2&#39;, ...`` .</span>

<span class="sd">               If conditions are separated by &#39;/&#39;, selects every item</span>
<span class="sd">               containing every list tag (e.g. [&#39;audio&#39;, &#39;left&#39;] selects</span>
<span class="sd">               &#39;audio/left&#39; and &#39;audio/center/left&#39;, but not &#39;audio/right&#39;).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">epochs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">epochs</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">,</span> <span class="n">data</span>
        <span class="k">del</span> <span class="bp">self</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">item</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> \
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">select</span> <span class="o">=</span> <span class="n">epochs</span><span class="o">.</span><span class="n">_keys_to_idx</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">select</span> <span class="o">=</span> <span class="n">item</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

        <span class="n">key_selection</span> <span class="o">=</span> <span class="n">epochs</span><span class="o">.</span><span class="n">selection</span><span class="p">[</span><span class="n">select</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">selection</span><span class="p">,</span> <span class="n">key_selection</span><span class="p">):</span>
            <span class="n">epochs</span><span class="o">.</span><span class="n">drop_log</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;IGNORED&#39;</span><span class="p">]</span>
        <span class="n">epochs</span><span class="o">.</span><span class="n">selection</span> <span class="o">=</span> <span class="n">key_selection</span>
        <span class="n">epochs</span><span class="o">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">select</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">epochs</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
            <span class="c1"># ensure that each Epochs instance owns its own data so we can</span>
            <span class="c1"># resize later if necessary</span>
            <span class="n">epochs</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">require</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">select</span><span class="p">],</span> <span class="n">requirements</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;O&#39;</span><span class="p">])</span>
        <span class="c1"># update event id to reflect new content of epochs</span>
        <span class="n">epochs</span><span class="o">.</span><span class="n">event_id</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">epochs</span><span class="o">.</span><span class="n">event_id</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                               <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">epochs</span><span class="o">.</span><span class="n">events</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">epochs</span>

    <span class="k">def</span> <span class="nf">crop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Crop a time interval from epochs object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tmin : float | None</span>
<span class="sd">            Start time of selection in seconds.</span>
<span class="sd">        tmax : float | None</span>
<span class="sd">            End time of selection in seconds.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        epochs : instance of Epochs</span>
<span class="sd">            The cropped epochs.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Unlike Python slices, MNE time intervals include both their end points;</span>
<span class="sd">        crop(tmin, tmax) returns the interval tmin &lt;= t &lt;= tmax.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># XXX this could be made to work on non-preloaded data...</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Modifying data of epochs is only supported &#39;</span>
                               <span class="s1">&#39;when preloading is used. Use preload=True &#39;</span>
                               <span class="s1">&#39;in the constructor.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tmin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span>
        <span class="k">elif</span> <span class="n">tmin</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;tmin is not in epochs time interval. tmin is set to &#39;</span>
                 <span class="s1">&#39;epochs.tmin&#39;</span><span class="p">)</span>
            <span class="n">tmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmin</span>

        <span class="k">if</span> <span class="n">tmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmax</span>
        <span class="k">elif</span> <span class="n">tmax</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmax</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s1">&#39;tmax is not in epochs time interval. tmax is set to &#39;</span>
                 <span class="s1">&#39;epochs.tmax&#39;</span><span class="p">)</span>
            <span class="n">tmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmax</span>

        <span class="n">tmask</span> <span class="o">=</span> <span class="n">_time_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> <span class="n">sfreq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="n">tmask</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_times</span><span class="p">[</span><span class="n">tmask</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">tmask</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sfreq</span><span class="p">,</span> <span class="n">npad</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="s1">&#39;boxcar&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resample data.</span>

<span class="sd">        .. note:: Data must be loaded.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sfreq : float</span>
<span class="sd">            New sample rate to use</span>
<span class="sd">        npad : int | str</span>
<span class="sd">            Amount to pad the start and end of the data.</span>
<span class="sd">            Can also be &quot;auto&quot; to use a padding that will result in</span>
<span class="sd">            a power-of-two size (can be much faster).</span>
<span class="sd">        window : string or tuple</span>
<span class="sd">            Window to use in resampling. See :func:`scipy.signal.resample`.</span>
<span class="sd">        n_jobs : int</span>
<span class="sd">            Number of jobs to run in parallel.</span>
<span class="sd">        verbose : bool, str, int, or None</span>
<span class="sd">            If not None, override default verbose level (see</span>
<span class="sd">            :func:`mne.verbose` :ref:`Logging documentation &lt;tut_logging&gt;` for</span>
<span class="sd">            more). Defaults to self.verbose.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        epochs : instance of Epochs</span>
<span class="sd">            The resampled epochs object.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        mne.Epochs.savgol_filter</span>
<span class="sd">        mne.io.Raw.resample</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For some data, it may be more accurate to use npad=0 to reduce</span>
<span class="sd">        artifacts. This is dataset dependent -- check your data!</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># XXX this could operate on non-preloaded data, too</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Can only resample preloaded data&#39;</span><span class="p">)</span>
        <span class="n">o_sfreq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">sfreq</span><span class="p">,</span> <span class="n">o_sfreq</span><span class="p">,</span> <span class="n">npad</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                              <span class="n">n_jobs</span><span class="o">=</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="c1"># adjust indirectly affected variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sfreq</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">times</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span> <span class="o">/</span>
                      <span class="n">sfreq</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">times</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return copy of Epochs instance.&quot;&quot;&quot;</span>
        <span class="n">raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span> <span class="o">=</span> <span class="n">raw</span>
        <span class="n">new</span><span class="o">.</span><span class="n">_raw</span> <span class="o">=</span> <span class="n">raw</span>
        <span class="k">return</span> <span class="n">new</span>

    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">split_size</span><span class="o">=</span><span class="s1">&#39;2GB&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Save epochs in a fif file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fname : str</span>
<span class="sd">            The name of the file, which should end with -epo.fif or</span>
<span class="sd">            -epo.fif.gz.</span>
<span class="sd">        split_size : string | int</span>
<span class="sd">            Large raw files are automatically split into multiple pieces. This</span>
<span class="sd">            parameter specifies the maximum size of each piece. If the</span>
<span class="sd">            parameter is an integer, it specifies the size in Bytes. It is</span>
<span class="sd">            also possible to pass a human-readable string, e.g., 100MB.</span>
<span class="sd">            Note: Due to FIFF file limitations, the maximum split size is 2GB.</span>

<span class="sd">            .. versionadded:: 0.10.0</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Bad epochs will be dropped before saving the epochs to disk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">check_fname</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;epochs&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;-epo.fif&#39;</span><span class="p">,</span> <span class="s1">&#39;-epo.fif.gz&#39;</span><span class="p">))</span>
        <span class="n">split_size</span> <span class="o">=</span> <span class="n">_get_split_size</span><span class="p">(</span><span class="n">split_size</span><span class="p">)</span>

        <span class="c1"># to know the length accurately. The get_data() call would drop</span>
        <span class="c1"># bad epochs anyway</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drop_bad</span><span class="p">()</span>
        <span class="n">total_size</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">total_size</span> <span class="o">/=</span> <span class="mi">2</span>  <span class="c1"># 64bit data converted to 32bit before writing.</span>
        <span class="n">n_parts</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">total_size</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">split_size</span><span class="p">)))</span>
        <span class="n">epoch_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)),</span> <span class="n">n_parts</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">part_idx</span><span class="p">,</span> <span class="n">epoch_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">epoch_idxs</span><span class="p">):</span>
            <span class="n">this_epochs</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">epoch_idx</span><span class="p">]</span> <span class="k">if</span> <span class="n">n_parts</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="bp">self</span>
            <span class="c1"># avoid missing event_ids in splits</span>
            <span class="n">this_epochs</span><span class="o">.</span><span class="n">event_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_id</span>
            <span class="n">_save_split</span><span class="p">(</span><span class="n">this_epochs</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">part_idx</span><span class="p">,</span> <span class="n">n_parts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">equalize_event_counts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event_ids</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;mintime&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Equalize the number of trials in each condition.</span>

<span class="sd">        It tries to make the remaining epochs occurring as close as possible in</span>
<span class="sd">        time. This method works based on the idea that if there happened to be</span>
<span class="sd">        some time-varying (like on the scale of minutes) noise characteristics</span>
<span class="sd">        during a recording, they could be compensated for (to some extent) in</span>
<span class="sd">        the equalization process. This method thus seeks to reduce any of</span>
<span class="sd">        those effects by minimizing the differences in the times of the events</span>
<span class="sd">        in the two sets of epochs. For example, if one had event times</span>
<span class="sd">        [1, 2, 3, 4, 120, 121] and the other one had [3.5, 4.5, 120.5, 121.5],</span>
<span class="sd">        it would remove events at times [1, 2] in the first epochs and not</span>
<span class="sd">        [20, 21].</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        event_ids : list</span>
<span class="sd">            The event types to equalize. Each entry in the list can either be</span>
<span class="sd">            a str (single event) or a list of str. In the case where one of</span>
<span class="sd">            the entries is a list of str, event_ids in that list will be</span>
<span class="sd">            grouped together before equalizing trial counts across conditions.</span>
<span class="sd">            In the case where partial matching is used (using &#39;/&#39; in</span>
<span class="sd">            `event_ids`), `event_ids` will be matched according to the</span>
<span class="sd">            provided tags, that is, processing works as if the event_ids</span>
<span class="sd">            matched by the provided tags had been supplied instead.</span>
<span class="sd">            The event_ids must identify nonoverlapping subsets of the epochs.</span>
<span class="sd">        method : str</span>
<span class="sd">            If &#39;truncate&#39;, events will be truncated from the end of each event</span>
<span class="sd">            list. If &#39;mintime&#39;, timing differences between each event list</span>
<span class="sd">            will be minimized.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        epochs : instance of Epochs</span>
<span class="sd">            The modified Epochs instance.</span>
<span class="sd">        indices : array of int</span>
<span class="sd">            Indices from the original events list that were dropped.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For example (if epochs.event_id was {&#39;Left&#39;: 1, &#39;Right&#39;: 2,</span>
<span class="sd">        &#39;Nonspatial&#39;:3}:</span>

<span class="sd">            epochs.equalize_event_counts([[&#39;Left&#39;, &#39;Right&#39;], &#39;Nonspatial&#39;])</span>

<span class="sd">        would equalize the number of trials in the &#39;Nonspatial&#39; condition with</span>
<span class="sd">        the total number of trials in the &#39;Left&#39; and &#39;Right&#39; conditions.</span>

<span class="sd">        If multiple indices are provided (e.g. &#39;Left&#39; and &#39;Right&#39; in the</span>
<span class="sd">        example above), it is not guaranteed that after equalization, the</span>
<span class="sd">        conditions will contribute evenly. E.g., it is possible to end up</span>
<span class="sd">        with 70 &#39;Nonspatial&#39; trials, 69 &#39;Left&#39; and 1 &#39;Right&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">event_ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;event_ids must have at least one element&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bad_dropped</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">drop_bad</span><span class="p">()</span>
        <span class="c1"># figure out how to equalize</span>
        <span class="n">eq_inds</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="c1"># deal with hierarchical tags</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_id</span>
        <span class="n">orig_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">event_ids</span><span class="p">)</span>
        <span class="n">tagging</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="s2">&quot;/&quot;</span> <span class="ow">in</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ids</span><span class="p">):</span>
            <span class="c1"># make string inputs a list of length 1</span>
            <span class="n">event_ids</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span>
                         <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">event_ids</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">ids_</span> <span class="ow">in</span> <span class="n">event_ids</span><span class="p">:</span>  <span class="c1"># check if tagging is attempted</span>
                <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">id_</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ids</span> <span class="k">for</span> <span class="n">id_</span> <span class="ow">in</span> <span class="n">ids_</span><span class="p">]):</span>
                    <span class="n">tagging</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># 1. treat everything that&#39;s not in event_id as a tag</span>
            <span class="c1"># 2a. for tags, find all the event_ids matched by the tags</span>
            <span class="c1"># 2b. for non-tag ids, just pass them directly</span>
            <span class="c1"># 3. do this for every input</span>
            <span class="n">event_ids</span> <span class="o">=</span> <span class="p">[[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ids</span> <span class="k">if</span> <span class="nb">all</span><span class="p">((</span><span class="n">tag</span> <span class="ow">in</span> <span class="n">k</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">id_</span><span class="p">))]</span>  <span class="c1"># find ids matching all tags</span>
                         <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">id__</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ids</span> <span class="k">for</span> <span class="n">id__</span> <span class="ow">in</span> <span class="n">id_</span><span class="p">)</span>
                         <span class="k">else</span> <span class="n">id_</span>  <span class="c1"># straight pass for non-tag inputs</span>
                         <span class="k">for</span> <span class="n">id_</span> <span class="ow">in</span> <span class="n">event_ids</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">id_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">event_ids</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">id_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="n">orig_ids</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;not found in the &quot;</span>
                                   <span class="s2">&quot;epoch object&#39;s event_id.&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">sub_id</span> <span class="ow">in</span> <span class="n">ids</span> <span class="k">for</span> <span class="n">sub_id</span> <span class="ow">in</span> <span class="n">id_</span><span class="p">]))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Don&#39;t mix hierarchical and regular event_ids&quot;</span>
                           <span class="s2">&quot; like in </span><span class="se">\&#39;</span><span class="si">%s</span><span class="se">\&#39;</span><span class="s2">.&quot;</span> <span class="o">%</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">id_</span><span class="p">))</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>

            <span class="c1"># raise for non-orthogonal tags</span>
            <span class="k">if</span> <span class="n">tagging</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">events_</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">.</span><span class="n">events</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">event_ids</span><span class="p">]</span>
                <span class="n">doubles</span> <span class="o">=</span> <span class="n">events_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">events_</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">doubles</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The two sets of epochs are &quot;</span>
                                     <span class="s2">&quot;overlapping. Provide an &quot;</span>
                                     <span class="s2">&quot;orthogonal selection.&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">eq</span> <span class="ow">in</span> <span class="n">event_ids</span><span class="p">:</span>
            <span class="n">eq_inds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keys_to_idx</span><span class="p">(</span><span class="n">eq</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">event_times</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">e</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">eq_inds</span><span class="p">]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">_get_drop_indices</span><span class="p">(</span><span class="n">event_times</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
        <span class="c1"># need to re-index indices</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">e</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">eq_inds</span><span class="p">,</span> <span class="n">indices</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;EQUALIZED_COUNT&#39;</span><span class="p">)</span>
        <span class="c1"># actually remove the indices</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">,</span> <span class="n">indices</span>


<span class="k">def</span> <span class="nf">_hid_match</span><span class="p">(</span><span class="n">event_id</span><span class="p">,</span> <span class="n">keys</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Match event IDs using HID selection.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    event_id : dict</span>
<span class="sd">        The event ID dictionary.</span>
<span class="sd">    keys : list | str</span>
<span class="sd">        The event ID or subset (for HID), or list of such items.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    use_keys : list</span>
<span class="sd">        The full keys that fit the selection criteria.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># form the hierarchical event ID mapping</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">keys</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="n">keys</span>
    <span class="n">use_keys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;keys must be strings, got </span><span class="si">%s</span><span class="s1"> (</span><span class="si">%s</span><span class="s1">)&#39;</span>
                           <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">key</span><span class="p">))</span>
        <span class="n">use_keys</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">event_id</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                        <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">use_keys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;Event &quot;</span><span class="si">%s</span><span class="s1">&quot; is not in Epochs.&#39;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>
    <span class="n">use_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">use_keys</span><span class="p">))</span>  <span class="c1"># deduplicate if necessary</span>
    <span class="k">return</span> <span class="n">use_keys</span>


<span class="k">def</span> <span class="nf">_check_baseline</span><span class="p">(</span><span class="n">baseline</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> <span class="n">sfreq</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check for a valid baseline.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">baseline</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">baseline</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">baseline</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`baseline=</span><span class="si">%s</span><span class="s1">` is an invalid argument.&#39;</span>
                             <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">baseline</span><span class="p">))</span>
        <span class="n">baseline_tmin</span><span class="p">,</span> <span class="n">baseline_tmax</span> <span class="o">=</span> <span class="n">baseline</span>
        <span class="n">tstep</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">sfreq</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">baseline_tmin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">baseline_tmin</span> <span class="o">=</span> <span class="n">tmin</span>
        <span class="n">baseline_tmin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">baseline_tmin</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">baseline_tmax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">baseline_tmax</span> <span class="o">=</span> <span class="n">tmax</span>
        <span class="n">baseline_tmax</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">baseline_tmax</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">baseline_tmin</span> <span class="o">&lt;</span> <span class="n">tmin</span> <span class="o">-</span> <span class="n">tstep</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Baseline interval (tmin = </span><span class="si">%s</span><span class="s2">) is outside of epoch &quot;</span>
                <span class="s2">&quot;data (tmin = </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">baseline_tmin</span><span class="p">,</span> <span class="n">tmin</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">baseline_tmax</span> <span class="o">&gt;</span> <span class="n">tmax</span> <span class="o">+</span> <span class="n">tstep</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Baseline interval (tmax = </span><span class="si">%s</span><span class="s2">) is outside of epoch &quot;</span>
                <span class="s2">&quot;data (tmax = </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">baseline_tmax</span><span class="p">,</span> <span class="n">tmax</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">baseline_tmin</span> <span class="o">&gt;</span> <span class="n">baseline_tmax</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Baseline min (</span><span class="si">%s</span><span class="s2">) must be less than baseline max (</span><span class="si">%s</span><span class="s2">)&quot;</span>
                <span class="o">%</span> <span class="p">(</span><span class="n">baseline_tmin</span><span class="p">,</span> <span class="n">baseline_tmax</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">baseline_tmin</span><span class="p">,</span> <span class="n">baseline_tmax</span>


<span class="k">def</span> <span class="nf">_drop_log_stats</span><span class="p">(</span><span class="n">drop_log</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;IGNORED&#39;</span><span class="p">,)):</span>
    <span class="sd">&quot;&quot;&quot;Compute drop log stats.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    drop_log : list of lists</span>
<span class="sd">        Epoch drop log from Epochs.drop_log.</span>
<span class="sd">    ignore : list</span>
<span class="sd">        The drop reasons to ignore.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    perc : float</span>
<span class="sd">        Total percentage of epochs dropped.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">drop_log</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">drop_log</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;drop_log must be a list of lists&#39;</span><span class="p">)</span>
    <span class="n">perc</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">drop_log</span>
                          <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">r</span> <span class="ow">in</span> <span class="n">ignore</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">d</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">perc</span>


<span class="k">class</span> <span class="nc">Epochs</span><span class="p">(</span><span class="n">BaseEpochs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Epochs extracted from a Raw instance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    raw : Raw object</span>
<span class="sd">        An instance of Raw.</span>
<span class="sd">    events : array of int, shape (n_events, 3)</span>
<span class="sd">        The events typically returned by the read_events function.</span>
<span class="sd">        If some events don&#39;t match the events of interest as specified</span>
<span class="sd">        by event_id, they will be marked as &#39;IGNORED&#39; in the drop log.</span>
<span class="sd">    event_id : int | list of int | dict | None</span>
<span class="sd">        The id of the event to consider. If dict,</span>
<span class="sd">        the keys can later be used to access associated events. Example:</span>
<span class="sd">        dict(auditory=1, visual=3). If int, a dict will be created with</span>
<span class="sd">        the id as string. If a list, all events with the IDs specified</span>
<span class="sd">        in the list are used. If None, all events will be used with</span>
<span class="sd">        and a dict is created with string integer names corresponding</span>
<span class="sd">        to the event id integers.</span>
<span class="sd">    tmin : float</span>
<span class="sd">        Start time before event. If nothing is provided, defaults to -0.2</span>
<span class="sd">    tmax : float</span>
<span class="sd">        End time after event. If nothing is provided, defaults to 0.5</span>
<span class="sd">    baseline : None or tuple of length 2 (default (None, 0))</span>
<span class="sd">        The time interval to apply baseline correction. If None do not apply</span>
<span class="sd">        it. If baseline is (a, b) the interval is between &quot;a (s)&quot; and &quot;b (s)&quot;.</span>
<span class="sd">        If a is None the beginning of the data is used and if b is None then b</span>
<span class="sd">        is set to the end of the interval. If baseline is equal to (None, None)</span>
<span class="sd">        all the time interval is used. Correction is applied by computing mean</span>
<span class="sd">        of the baseline period and subtracting it from the data. The baseline</span>
<span class="sd">        (a, b) includes both endpoints, i.e. all timepoints t such that</span>
<span class="sd">        a &lt;= t &lt;= b.</span>
<span class="sd">    picks : array-like of int | None (default)</span>
<span class="sd">        Indices of channels to include (if None, all channels are used).</span>
<span class="sd">    preload : boolean</span>
<span class="sd">        Load all epochs from disk when creating the object</span>
<span class="sd">        or wait before accessing each epoch (more memory</span>
<span class="sd">        efficient but can be slower).</span>
<span class="sd">    reject : dict | None</span>
<span class="sd">        Rejection parameters based on peak-to-peak amplitude.</span>
<span class="sd">        Valid keys are &#39;grad&#39; | &#39;mag&#39; | &#39;eeg&#39; | &#39;eog&#39; | &#39;ecg&#39;.</span>
<span class="sd">        If reject is None then no rejection is done. Example::</span>

<span class="sd">            reject = dict(grad=4000e-13, # T / m (gradiometers)</span>
<span class="sd">                          mag=4e-12, # T (magnetometers)</span>
<span class="sd">                          eeg=40e-6, # V (EEG channels)</span>
<span class="sd">                          eog=250e-6 # V (EOG channels)</span>
<span class="sd">                          )</span>

<span class="sd">    flat : dict | None</span>
<span class="sd">        Rejection parameters based on flatness of signal.</span>
<span class="sd">        Valid keys are &#39;grad&#39; | &#39;mag&#39; | &#39;eeg&#39; | &#39;eog&#39; | &#39;ecg&#39;, and values</span>
<span class="sd">        are floats that set the minimum acceptable peak-to-peak amplitude.</span>
<span class="sd">        If flat is None then no rejection is done.</span>
<span class="sd">    proj : bool | &#39;delayed&#39;</span>
<span class="sd">        Apply SSP projection vectors. If proj is &#39;delayed&#39; and reject is not</span>
<span class="sd">        None the single epochs will be projected before the rejection</span>
<span class="sd">        decision, but used in unprojected state if they are kept.</span>
<span class="sd">        This way deciding which projection vectors are good can be postponed</span>
<span class="sd">        to the evoked stage without resulting in lower epoch counts and</span>
<span class="sd">        without producing results different from early SSP application</span>
<span class="sd">        given comparable parameters. Note that in this case baselining,</span>
<span class="sd">        detrending and temporal decimation will be postponed.</span>
<span class="sd">        If proj is False no projections will be applied which is the</span>
<span class="sd">        recommended value if SSPs are not used for cleaning the data.</span>
<span class="sd">    decim : int</span>
<span class="sd">        Factor by which to downsample the data from the raw file upon import.</span>
<span class="sd">        Warning: This simply selects every nth sample, data is not filtered</span>
<span class="sd">        here. If data is not properly filtered, aliasing artifacts may occur.</span>
<span class="sd">    reject_tmin : scalar | None</span>
<span class="sd">        Start of the time window used to reject epochs (with the default None,</span>
<span class="sd">        the window will start with tmin).</span>
<span class="sd">    reject_tmax : scalar | None</span>
<span class="sd">        End of the time window used to reject epochs (with the default None,</span>
<span class="sd">        the window will end with tmax).</span>
<span class="sd">    detrend : int | None</span>
<span class="sd">        If 0 or 1, the data channels (MEG and EEG) will be detrended when</span>
<span class="sd">        loaded. 0 is a constant (DC) detrend, 1 is a linear detrend. None</span>
<span class="sd">        is no detrending. Note that detrending is performed before baseline</span>
<span class="sd">        correction. If no DC offset is preferred (zeroth order detrending),</span>
<span class="sd">        either turn off baseline correction, as this may introduce a DC</span>
<span class="sd">        shift, or set baseline correction to use the entire time interval</span>
<span class="sd">        (will yield equivalent results but be slower).</span>
<span class="sd">    on_missing : str</span>
<span class="sd">        What to do if one or several event ids are not found in the recording.</span>
<span class="sd">        Valid keys are &#39;error&#39; | &#39;warning&#39; | &#39;ignore&#39;</span>
<span class="sd">        Default is &#39;error&#39;. If on_missing is &#39;warning&#39; it will proceed but</span>
<span class="sd">        warn, if &#39;ignore&#39; it will proceed silently. Note.</span>
<span class="sd">        If none of the event ids are found in the data, an error will be</span>
<span class="sd">        automatically generated irrespective of this parameter.</span>
<span class="sd">    reject_by_annotation : bool</span>
<span class="sd">        Whether to reject based on annotations. If True (default), epochs</span>
<span class="sd">        overlapping with segments whose description begins with ``&#39;bad&#39;`` are</span>
<span class="sd">        rejected. If False, no rejection based on annotations is performed.</span>
<span class="sd">    verbose : bool, str, int, or None</span>
<span class="sd">        If not None, override default verbose level (see :func:`mne.verbose`</span>
<span class="sd">        and :ref:`Logging documentation &lt;tut_logging&gt;` for more). Defaults to</span>
<span class="sd">        raw.verbose.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    info : instance of Info</span>
<span class="sd">        Measurement info.</span>
<span class="sd">    event_id : dict</span>
<span class="sd">        Names of conditions corresponding to event_ids.</span>
<span class="sd">    ch_names : list of string</span>
<span class="sd">        List of channel names.</span>
<span class="sd">    selection : array</span>
<span class="sd">        List of indices of selected events (not dropped or ignored etc.). For</span>
<span class="sd">        example, if the original event array had 4 events and the second event</span>
<span class="sd">        has been dropped, this attribute would be np.array([0, 2, 3]).</span>
<span class="sd">    preload : bool</span>
<span class="sd">        Indicates whether epochs are in memory.</span>
<span class="sd">    drop_log : list of lists</span>
<span class="sd">        A list of the same length as the event array used to initialize the</span>
<span class="sd">        Epochs object. If the i-th original event is still part of the</span>
<span class="sd">        selection, drop_log[i] will be an empty list; otherwise it will be</span>
<span class="sd">        a list of the reasons the event is not longer in the selection, e.g.:</span>

<span class="sd">        &#39;IGNORED&#39; if it isn&#39;t part of the current subset defined by the user;</span>
<span class="sd">        &#39;NO_DATA&#39; or &#39;TOO_SHORT&#39; if epoch didn&#39;t contain enough data;</span>
<span class="sd">        names of channels that exceeded the amplitude threshold;</span>
<span class="sd">        &#39;EQUALIZED_COUNTS&#39; (see equalize_event_counts);</span>
<span class="sd">        or &#39;USER&#39; for user-defined reasons (see drop method).</span>
<span class="sd">    filename : str</span>
<span class="sd">        The filename of the object.</span>
<span class="sd">    verbose : bool, str, int, or None</span>
<span class="sd">        See above.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mne.epochs.combine_event_ids</span>
<span class="sd">    mne.Epochs.equalize_event_counts</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    When accessing data, Epochs are detrended, baseline-corrected, and</span>
<span class="sd">    decimated, then projectors are (optionally) applied.</span>

<span class="sd">    For indexing and slicing using ``epochs[...]``, see</span>
<span class="sd">    :func:`mne.Epochs.__getitem__`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">event_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=-</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                 <span class="n">baseline</span><span class="o">=</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">preload</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">reject</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">decim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">reject_tmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">reject_tmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">on_missing</span><span class="o">=</span><span class="s1">&#39;error&#39;</span><span class="p">,</span>
                 <span class="n">reject_by_annotation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># noqa: D102</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="n">BaseRaw</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The first argument to `Epochs` must be an &#39;</span>
                             <span class="s1">&#39;instance of `mne.io.Raw`&#39;</span><span class="p">)</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">raw</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>

        <span class="c1"># proj is on when applied in Raw</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="n">proj</span> <span class="ow">or</span> <span class="n">raw</span><span class="o">.</span><span class="n">proj</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reject_by_annotation</span> <span class="o">=</span> <span class="n">reject_by_annotation</span>
        <span class="c1"># call BaseEpochs constructor</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Epochs</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">info</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">event_id</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> <span class="n">baseline</span><span class="o">=</span><span class="n">baseline</span><span class="p">,</span>
            <span class="n">raw</span><span class="o">=</span><span class="n">raw</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="n">picks</span><span class="p">,</span> <span class="n">reject</span><span class="o">=</span><span class="n">reject</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="n">flat</span><span class="p">,</span> <span class="n">decim</span><span class="o">=</span><span class="n">decim</span><span class="p">,</span>
            <span class="n">reject_tmin</span><span class="o">=</span><span class="n">reject_tmin</span><span class="p">,</span> <span class="n">reject_tmax</span><span class="o">=</span><span class="n">reject_tmax</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span>
            <span class="n">proj</span><span class="o">=</span><span class="n">proj</span><span class="p">,</span> <span class="n">on_missing</span><span class="o">=</span><span class="n">on_missing</span><span class="p">,</span> <span class="n">preload_at_end</span><span class="o">=</span><span class="n">preload</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">_get_epoch_from_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load one epoch from disk.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : array | str | None</span>
<span class="sd">            If string it&#39;s details on rejection reason.</span>
<span class="sd">            If None it means no data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># This should never happen, as raw=None only if preload=True</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;An error has occurred, no valid raw file found.&#39;</span>
                             <span class="s1">&#39; Please report this to the mne-python &#39;</span>
                             <span class="s1">&#39;developers.&#39;</span><span class="p">)</span>
        <span class="n">sfreq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span>
        <span class="n">event_samp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Read a data segment</span>
        <span class="n">first_samp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span><span class="o">.</span><span class="n">first_samp</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">event_samp</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw_times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">sfreq</span><span class="p">))</span>
        <span class="n">start</span> <span class="o">-=</span> <span class="n">first_samp</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_raw_times</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span><span class="o">.</span><span class="n">_check_bad_segment</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">picks</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">reject_by_annotation</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>


<span class="k">class</span> <span class="nc">EpochsArray</span><span class="p">(</span><span class="n">BaseEpochs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Epochs object from numpy array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array, shape (n_epochs, n_channels, n_times)</span>
<span class="sd">        The channels&#39; time series for each epoch. See notes for proper units of</span>
<span class="sd">        measure.</span>
<span class="sd">    info : instance of Info</span>
<span class="sd">        Info dictionary. Consider using ``create_info`` to populate</span>
<span class="sd">        this structure.</span>
<span class="sd">    events : None | array of int, shape (n_events, 3)</span>
<span class="sd">        The events typically returned by the read_events function.</span>
<span class="sd">        If some events don&#39;t match the events of interest as specified</span>
<span class="sd">        by event_id, they will be marked as &#39;IGNORED&#39; in the drop log.</span>
<span class="sd">        If None (default), all event values are set to 1 and event time-samples</span>
<span class="sd">        are set to range(n_epochs).</span>
<span class="sd">    tmin : float</span>
<span class="sd">        Start time before event. If nothing provided, defaults to -0.2.</span>
<span class="sd">    event_id : int | list of int | dict | None</span>
<span class="sd">        The id of the event to consider. If dict,</span>
<span class="sd">        the keys can later be used to access associated events. Example:</span>
<span class="sd">        dict(auditory=1, visual=3). If int, a dict will be created with</span>
<span class="sd">        the id as string. If a list, all events with the IDs specified</span>
<span class="sd">        in the list are used. If None, all events will be used with</span>
<span class="sd">        and a dict is created with string integer names corresponding</span>
<span class="sd">        to the event id integers.</span>
<span class="sd">    reject : dict | None</span>
<span class="sd">        Rejection parameters based on peak-to-peak amplitude.</span>
<span class="sd">        Valid keys are &#39;grad&#39; | &#39;mag&#39; | &#39;eeg&#39; | &#39;eog&#39; | &#39;ecg&#39;.</span>
<span class="sd">        If reject is None then no rejection is done. Example::</span>

<span class="sd">            reject = dict(grad=4000e-13, # T / m (gradiometers)</span>
<span class="sd">                          mag=4e-12, # T (magnetometers)</span>
<span class="sd">                          eeg=40e-6, # V (EEG channels)</span>
<span class="sd">                          eog=250e-6 # V (EOG channels)</span>
<span class="sd">                          )</span>

<span class="sd">    flat : dict | None</span>
<span class="sd">        Rejection parameters based on flatness of signal.</span>
<span class="sd">        Valid keys are &#39;grad&#39; | &#39;mag&#39; | &#39;eeg&#39; | &#39;eog&#39; | &#39;ecg&#39;, and values</span>
<span class="sd">        are floats that set the minimum acceptable peak-to-peak amplitude.</span>
<span class="sd">        If flat is None then no rejection is done.</span>
<span class="sd">    reject_tmin : scalar | None</span>
<span class="sd">        Start of the time window used to reject epochs (with the default None,</span>
<span class="sd">        the window will start with tmin).</span>
<span class="sd">    reject_tmax : scalar | None</span>
<span class="sd">        End of the time window used to reject epochs (with the default None,</span>
<span class="sd">        the window will end with tmax).</span>
<span class="sd">    baseline : None or tuple of length 2 (default None)</span>
<span class="sd">        The time interval to apply baseline correction. If None do not apply</span>
<span class="sd">        it. If baseline is (a, b) the interval is between &quot;a (s)&quot; and &quot;b (s)&quot;.</span>
<span class="sd">        If a is None the beginning of the data is used and if b is None then b</span>
<span class="sd">        is set to the end of the interval. If baseline is equal to (None, None)</span>
<span class="sd">        all the time interval is used. Correction is applied by computing mean</span>
<span class="sd">        of the baseline period and subtracting it from the data. The baseline</span>
<span class="sd">        (a, b) includes both endpoints, i.e. all timepoints t such that</span>
<span class="sd">        a &lt;= t &lt;= b.</span>
<span class="sd">    proj : bool | &#39;delayed&#39;</span>
<span class="sd">        Apply SSP projection vectors. See :class:`mne.Epochs` for details.</span>
<span class="sd">    on_missing : str</span>
<span class="sd">        See :class:`mne.Epochs` docstring for details.</span>
<span class="sd">    verbose : bool, str, int, or None</span>
<span class="sd">        If not None, override default verbose level (see :func:`mne.verbose`</span>
<span class="sd">        and :ref:`Logging documentation &lt;tut_logging&gt;` for more).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Proper units of measure:</span>
<span class="sd">    * V: eeg, eog, seeg, emg, ecg, bio, ecog</span>
<span class="sd">    * T: mag</span>
<span class="sd">    * T/m: grad</span>
<span class="sd">    * M: hbo, hbr</span>
<span class="sd">    * Am: dipole</span>
<span class="sd">    * AU: misc</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    io.RawArray, EvokedArray, create_info</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">events</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">event_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">reject</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reject_tmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">reject_tmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">baseline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">on_missing</span><span class="o">=</span><span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># noqa: D102</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Data must be a 3D array of shape (n_epochs, &#39;</span>
                             <span class="s1">&#39;n_channels, n_samples)&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">])</span> <span class="o">!=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Info and data must have same number of &#39;</span>
                             <span class="s1">&#39;channels.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">events</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n_epochs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="n">events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_epochs</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_epochs</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_epochs</span><span class="p">,</span> <span class="nb">int</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The number of epochs and the number of events&#39;</span>
                             <span class="s1">&#39;must match&#39;</span><span class="p">)</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># do not modify original info</span>
        <span class="n">tmax</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">tmin</span>
        <span class="k">if</span> <span class="n">event_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># convert to int to make typing-checks happy</span>
            <span class="n">event_id</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="p">))</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">events</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]))</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">EpochsArray</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">event_id</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span>
                                          <span class="n">tmax</span><span class="p">,</span> <span class="n">baseline</span><span class="p">,</span> <span class="n">reject</span><span class="o">=</span><span class="n">reject</span><span class="p">,</span>
                                          <span class="n">flat</span><span class="o">=</span><span class="n">flat</span><span class="p">,</span> <span class="n">reject_tmin</span><span class="o">=</span><span class="n">reject_tmin</span><span class="p">,</span>
                                          <span class="n">reject_tmax</span><span class="o">=</span><span class="n">reject_tmax</span><span class="p">,</span> <span class="n">decim</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                          <span class="n">proj</span><span class="o">=</span><span class="n">proj</span><span class="p">,</span> <span class="n">on_missing</span><span class="o">=</span><span class="n">on_missing</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">)</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>
                                  <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">event_id</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span><span class="o">.</span><span class="n">sum</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The events must only contain event numbers from &#39;</span>
                             <span class="s1">&#39;event_id&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">):</span>
            <span class="c1"># This is safe without assignment b/c there is no decim</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_detrend_offset_decim</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drop_bad</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">combine_event_ids</span><span class="p">(</span><span class="n">epochs</span><span class="p">,</span> <span class="n">old_event_ids</span><span class="p">,</span> <span class="n">new_event_id</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Collapse event_ids from an epochs instance into a new event_id.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    epochs : instance of Epochs</span>
<span class="sd">        The epochs to operate on.</span>
<span class="sd">    old_event_ids : str, or list</span>
<span class="sd">        Conditions to collapse together.</span>
<span class="sd">    new_event_id : dict, or int</span>
<span class="sd">        A one-element dict (or a single integer) for the new</span>
<span class="sd">        condition. Note that for safety, this cannot be any</span>
<span class="sd">        existing id (in epochs.event_id.values()).</span>
<span class="sd">    copy : bool</span>
<span class="sd">        Whether to return a new instance or modify in place.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This For example (if epochs.event_id was {&#39;Left&#39;: 1, &#39;Right&#39;: 2}:</span>

<span class="sd">        combine_event_ids(epochs, [&#39;Left&#39;, &#39;Right&#39;], {&#39;Directional&#39;: 12})</span>

<span class="sd">    would create a &#39;Directional&#39; entry in epochs.event_id replacing</span>
<span class="sd">    &#39;Left&#39; and &#39;Right&#39; (combining their trials).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">epochs</span> <span class="o">=</span> <span class="n">epochs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="n">epochs</span>
    <span class="n">old_event_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">old_event_ids</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_event_id</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">new_event_id</span> <span class="o">=</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">new_event_id</span><span class="p">):</span> <span class="n">new_event_id</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_event_id</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;new_event_id must be a dict or int&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">new_event_id</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;new_event_id dict must have one entry&#39;</span><span class="p">)</span>
    <span class="n">new_event_num</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_event_id</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_event_num</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;new_event_id value must be an integer&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">new_event_num</span> <span class="ow">in</span> <span class="n">epochs</span><span class="o">.</span><span class="n">event_id</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;new_event_id value must not already exist&#39;</span><span class="p">)</span>
    <span class="c1"># could use .pop() here, but if a latter one doesn&#39;t exist, we&#39;re</span>
    <span class="c1"># in trouble, so run them all here and pop() later</span>
    <span class="n">old_event_nums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">epochs</span><span class="o">.</span><span class="n">event_id</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">old_event_ids</span><span class="p">])</span>
    <span class="c1"># find the ones to replace</span>
    <span class="n">inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">events</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">][:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">==</span>
                  <span class="n">old_event_nums</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># replace the event numbers in the events list</span>
    <span class="n">epochs</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">inds</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_event_num</span>
    <span class="c1"># delete old entries</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">old_event_ids</span><span class="p">:</span>
        <span class="n">epochs</span><span class="o">.</span><span class="n">event_id</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="c1"># add the new entry</span>
    <span class="n">epochs</span><span class="o">.</span><span class="n">event_id</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_event_id</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">epochs</span>


<span class="k">def</span> <span class="nf">equalize_epoch_counts</span><span class="p">(</span><span class="n">epochs_list</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;mintime&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Equalize the number of trials in multiple Epoch instances.</span>

<span class="sd">    It tries to make the remaining epochs occurring as close as possible in</span>
<span class="sd">    time. This method works based on the idea that if there happened to be some</span>
<span class="sd">    time-varying (like on the scale of minutes) noise characteristics during</span>
<span class="sd">    a recording, they could be compensated for (to some extent) in the</span>
<span class="sd">    equalization process. This method thus seeks to reduce any of those effects</span>
<span class="sd">    by minimizing the differences in the times of the events in the two sets of</span>
<span class="sd">    epochs. For example, if one had event times [1, 2, 3, 4, 120, 121] and the</span>
<span class="sd">    other one had [3.5, 4.5, 120.5, 121.5], it would remove events at times</span>
<span class="sd">    [1, 2] in the first epochs and not [120, 121].</span>

<span class="sd">    Note that this operates on the Epochs instances in-place.</span>

<span class="sd">    Example:</span>

<span class="sd">        equalize_epoch_counts(epochs1, epochs2)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    epochs_list : list of Epochs instances</span>
<span class="sd">        The Epochs instances to equalize trial counts for.</span>
<span class="sd">    method : str</span>
<span class="sd">        If &#39;truncate&#39;, events will be truncated from the end of each event</span>
<span class="sd">        list. If &#39;mintime&#39;, timing differences between each event list will be</span>
<span class="sd">        minimized.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">BaseEpochs</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">epochs_list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All inputs must be Epochs instances&#39;</span><span class="p">)</span>

    <span class="c1"># make sure bad epochs are dropped</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">epochs_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span><span class="o">.</span><span class="n">_bad_dropped</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">drop_bad</span><span class="p">()</span>
    <span class="n">event_times</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">events</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">epochs_list</span><span class="p">]</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">_get_drop_indices</span><span class="p">(</span><span class="n">event_times</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">inds</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">epochs_list</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
        <span class="n">e</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">inds</span><span class="p">,</span> <span class="n">reason</span><span class="o">=</span><span class="s1">&#39;EQUALIZED_COUNT&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_drop_indices</span><span class="p">(</span><span class="n">event_times</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Get indices to drop from multiple event timing lists.&quot;&quot;&quot;</span>
    <span class="n">small_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">([</span><span class="n">e</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">event_times</span><span class="p">])</span>
    <span class="n">small_e_times</span> <span class="o">=</span> <span class="n">event_times</span><span class="p">[</span><span class="n">small_idx</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;mintime&#39;</span><span class="p">,</span> <span class="s1">&#39;truncate&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;method must be either mintime or truncate, not &#39;</span>
                         <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">event_times</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;mintime&#39;</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">_minimize_time_diff</span><span class="p">(</span><span class="n">small_e_times</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="n">mask</span><span class="p">[</span><span class="n">small_e_times</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">mask</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">indices</span>


<span class="k">def</span> <span class="nf">_fix_fill</span><span class="p">(</span><span class="n">fill</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fix bug on old scipy.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">LooseVersion</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">__version__</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">LooseVersion</span><span class="p">(</span><span class="s1">&#39;0.12&#39;</span><span class="p">):</span>
        <span class="n">fill</span> <span class="o">=</span> <span class="n">fill</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">fill</span>


<span class="k">def</span> <span class="nf">_minimize_time_diff</span><span class="p">(</span><span class="n">t_shorter</span><span class="p">,</span> <span class="n">t_longer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Find a boolean mask to minimize timing differences.&quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="k">import</span> <span class="n">interp1d</span>
    <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">t_longer</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_shorter</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">keep</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">keep</span>
    <span class="n">scores</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">t_longer</span><span class="p">)))</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t_shorter</span><span class="p">))</span>
    <span class="c1"># The first set of keep masks to test</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="c1"># this is a speed tweak, only exists for certain versions of scipy</span>
    <span class="k">if</span> <span class="s1">&#39;assume_sorted&#39;</span> <span class="ow">in</span> <span class="n">_get_args</span><span class="p">(</span><span class="n">interp1d</span><span class="o">.</span><span class="fm">__init__</span><span class="p">):</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;assume_sorted&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">shorter_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">t_shorter</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">t_shorter</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                              <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t_longer</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_shorter</span><span class="p">)):</span>
        <span class="n">scores</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="c1"># set up the keep masks to test, eliminating any rows that are already</span>
        <span class="c1"># gone</span>
        <span class="n">keep_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t_longer</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)[</span><span class="n">keep</span><span class="p">]</span>
        <span class="n">keep_mask</span><span class="p">[:,</span> <span class="o">~</span><span class="n">keep</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Check every possible removal to see if it minimizes</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t_longer</span><span class="p">)</span> <span class="o">-</span> <span class="n">ii</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">t_keeps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">t_longer</span><span class="p">[</span><span class="n">km</span><span class="p">]</span> <span class="k">for</span> <span class="n">km</span> <span class="ow">in</span> <span class="n">keep_mask</span><span class="p">])</span>
        <span class="n">longer_interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">t_keeps</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                 <span class="n">fill_value</span><span class="o">=</span><span class="n">_fix_fill</span><span class="p">(</span><span class="n">t_keeps</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                                 <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">d1</span> <span class="o">=</span> <span class="n">longer_interp</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">-</span> <span class="n">t_shorter</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="n">shorter_interp</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="o">-</span> <span class="n">t_keeps</span>
        <span class="n">scores</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">d2</span><span class="p">,</span> <span class="n">d2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">keep</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">scores</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">keep</span>


<span class="nd">@verbose</span>
<span class="k">def</span> <span class="nf">_is_good</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">ch_names</span><span class="p">,</span> <span class="n">channel_type_idx</span><span class="p">,</span> <span class="n">reject</span><span class="p">,</span> <span class="n">flat</span><span class="p">,</span> <span class="n">full_report</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">ignore_chs</span><span class="o">=</span><span class="p">[],</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Test if data segment e is good according to reject and flat.</span>

<span class="sd">    If full_report=True, it will give True/False as well as a list of all</span>
<span class="sd">    offending channels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bad_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">has_printed</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">checkable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ch_names</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">checkable</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span> <span class="ow">in</span> <span class="n">ignore_chs</span>
                        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ch_names</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">refl</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="n">reject</span><span class="p">,</span> <span class="n">flat</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">greater</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">less</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;flat&#39;</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">refl</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">thresh</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">refl</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">channel_type_idx</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">e_idx</span> <span class="o">=</span> <span class="n">e</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="n">deltas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">e_idx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">e_idx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">checkable_idx</span> <span class="o">=</span> <span class="n">checkable</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="n">idx_deltas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">deltas</span><span class="p">,</span> <span class="n">thresh</span><span class="p">),</span>
                                                         <span class="n">checkable_idx</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_deltas</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">ch_name</span> <span class="o">=</span> <span class="p">[</span><span class="n">ch_names</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx_deltas</span><span class="p">]</span>
                        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">has_printed</span><span class="p">):</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;    Rejecting </span><span class="si">%s</span><span class="s1"> epoch based on </span><span class="si">%s</span><span class="s1"> : &#39;</span>
                                        <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">ch_name</span><span class="p">))</span>
                            <span class="n">has_printed</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">full_report</span><span class="p">:</span>
                            <span class="k">return</span> <span class="kc">False</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">bad_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ch_name</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">full_report</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bad_list</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">return</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="n">bad_list</span>


<span class="k">def</span> <span class="nf">_read_one_epoch_file</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">preload</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Read a single FIF file.&quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">f</span> <span class="k">as</span> <span class="n">fid</span><span class="p">:</span>
        <span class="c1">#   Read the measurement info</span>
        <span class="n">info</span><span class="p">,</span> <span class="n">meas</span> <span class="o">=</span> <span class="n">read_meas_info</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">clean_bads</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">events</span><span class="p">,</span> <span class="n">mappings</span> <span class="o">=</span> <span class="n">_read_events_fif</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>

        <span class="c1">#   Locate the data of interest</span>
        <span class="n">processed</span> <span class="o">=</span> <span class="n">dir_tree_find</span><span class="p">(</span><span class="n">meas</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_PROCESSED_DATA</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">processed</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Could not find processed data&#39;</span><span class="p">)</span>

        <span class="n">epochs_node</span> <span class="o">=</span> <span class="n">dir_tree_find</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_MNE_EPOCHS</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">epochs_node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># before version 0.11 we errantly saved with this tag instead of</span>
            <span class="c1"># an MNE tag</span>
            <span class="n">epochs_node</span> <span class="o">=</span> <span class="n">dir_tree_find</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_MNE_EPOCHS</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">epochs_node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">epochs_node</span> <span class="o">=</span> <span class="n">dir_tree_find</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="mi">122</span><span class="p">)</span>  <span class="c1"># 122 used before v0.11</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">epochs_node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Could not find epochs data&#39;</span><span class="p">)</span>

        <span class="n">my_epochs</span> <span class="o">=</span> <span class="n">epochs_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Now find the data in the block</span>
        <span class="n">data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">data_tag</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">bmin</span><span class="p">,</span> <span class="n">bmax</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="n">baseline</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">drop_log</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">my_epochs</span><span class="p">[</span><span class="s1">&#39;nent&#39;</span><span class="p">]):</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="n">my_epochs</span><span class="p">[</span><span class="s1">&#39;directory&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">kind</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">my_epochs</span><span class="p">[</span><span class="s1">&#39;directory&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">pos</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_FIRST_SAMPLE</span><span class="p">:</span>
                <span class="n">tag</span> <span class="o">=</span> <span class="n">read_tag</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
                <span class="n">first</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_LAST_SAMPLE</span><span class="p">:</span>
                <span class="n">tag</span> <span class="o">=</span> <span class="n">read_tag</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
                <span class="n">last</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_EPOCH</span><span class="p">:</span>
                <span class="c1"># delay reading until later</span>
                <span class="n">fid</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">data_tag</span> <span class="o">=</span> <span class="n">read_tag_info</span><span class="p">(</span><span class="n">fid</span><span class="p">)</span>
                <span class="n">data_tag</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span>
            <span class="k">elif</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_MNE_BASELINE_MIN</span><span class="p">,</span> <span class="mi">304</span><span class="p">]:</span>
                <span class="c1"># Constant 304 was used before v0.11</span>
                <span class="n">tag</span> <span class="o">=</span> <span class="n">read_tag</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
                <span class="n">bmin</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">[</span><span class="n">FIFF</span><span class="o">.</span><span class="n">FIFF_MNE_BASELINE_MAX</span><span class="p">,</span> <span class="mi">305</span><span class="p">]:</span>
                <span class="c1"># Constant 305 was used before v0.11</span>
                <span class="n">tag</span> <span class="o">=</span> <span class="n">read_tag</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
                <span class="n">bmax</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_MNE_EPOCHS_SELECTION</span><span class="p">:</span>
                <span class="n">tag</span> <span class="o">=</span> <span class="n">read_tag</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
                <span class="n">selection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">FIFF</span><span class="o">.</span><span class="n">FIFFB_MNE_EPOCHS_DROP_LOG</span><span class="p">:</span>
                <span class="n">tag</span> <span class="o">=</span> <span class="n">read_tag</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
                <span class="n">drop_log</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">bmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">baseline</span> <span class="o">=</span> <span class="p">(</span><span class="n">bmin</span><span class="p">,</span> <span class="n">bmax</span><span class="p">)</span>

        <span class="n">n_samp</span> <span class="o">=</span> <span class="n">last</span> <span class="o">-</span> <span class="n">first</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;    Found the data of interest:&#39;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;        t = </span><span class="si">%10.2f</span><span class="s1"> ... </span><span class="si">%10.2f</span><span class="s1"> ms&#39;</span>
                    <span class="o">%</span> <span class="p">(</span><span class="mi">1000</span> <span class="o">*</span> <span class="n">first</span> <span class="o">/</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">],</span>
                       <span class="mi">1000</span> <span class="o">*</span> <span class="n">last</span> <span class="o">/</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;comps&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;        </span><span class="si">%d</span><span class="s1"> CTF compensation matrices available&#39;</span>
                        <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;comps&#39;</span><span class="p">]))</span>

        <span class="c1"># Inspect the data</span>
        <span class="k">if</span> <span class="n">data_tag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Epochs data not found&#39;</span><span class="p">)</span>
        <span class="n">epoch_shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">]),</span> <span class="n">n_samp</span><span class="p">)</span>
        <span class="n">expected</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">epoch_shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">data_tag</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="mi">4</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">!=</span> <span class="n">expected</span><span class="p">:</span>  <span class="c1"># 32-bit floats stored</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Incorrect number of samples (</span><span class="si">%d</span><span class="s1"> instead of </span><span class="si">%d</span><span class="s1">)&#39;</span>
                             <span class="o">%</span> <span class="p">(</span><span class="n">data_tag</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="mi">4</span><span class="p">,</span> <span class="n">expected</span><span class="p">))</span>

        <span class="c1"># Calibration factors</span>
        <span class="n">cals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="s1">&#39;cal&#39;</span><span class="p">]</span> <span class="o">*</span>
                          <span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;scale&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)]</span>
                         <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">])],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="c1"># Read the data</span>
        <span class="k">if</span> <span class="n">preload</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">read_tag</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">data_tag</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">*=</span> <span class="n">cals</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>

        <span class="c1"># Put it all together</span>
        <span class="n">tmin</span> <span class="o">=</span> <span class="n">first</span> <span class="o">/</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span>
        <span class="n">tmax</span> <span class="o">=</span> <span class="n">last</span> <span class="o">/</span> <span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span>
        <span class="n">event_id</span> <span class="o">=</span> <span class="p">(</span><span class="nb">dict</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">events</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="n">mappings</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">mappings</span><span class="p">)</span>
        <span class="c1"># In case epochs didn&#39;t have a FIFF.FIFFB_MNE_EPOCHS_SELECTION tag</span>
        <span class="c1"># (version &lt; 0.8):</span>
        <span class="k">if</span> <span class="n">selection</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">selection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">drop_log</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">drop_log</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">))]</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">data_tag</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">event_id</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> <span class="n">baseline</span><span class="p">,</span>
            <span class="n">selection</span><span class="p">,</span> <span class="n">drop_log</span><span class="p">,</span> <span class="n">epoch_shape</span><span class="p">,</span> <span class="n">cals</span><span class="p">)</span>


<span class="nd">@verbose</span>
<span class="k">def</span> <span class="nf">read_epochs</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">preload</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Read epochs from a fif file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str</span>
<span class="sd">        The name of the file, which should end with -epo.fif or -epo.fif.gz.</span>
<span class="sd">    proj : bool | &#39;delayed&#39;</span>
<span class="sd">        Apply SSP projection vectors. If proj is &#39;delayed&#39; and reject is not</span>
<span class="sd">        None the single epochs will be projected before the rejection</span>
<span class="sd">        decision, but used in unprojected state if they are kept.</span>
<span class="sd">        This way deciding which projection vectors are good can be postponed</span>
<span class="sd">        to the evoked stage without resulting in lower epoch counts and</span>
<span class="sd">        without producing results different from early SSP application</span>
<span class="sd">        given comparable parameters. Note that in this case baselining,</span>
<span class="sd">        detrending and temporal decimation will be postponed.</span>
<span class="sd">        If proj is False no projections will be applied which is the</span>
<span class="sd">        recommended value if SSPs are not used for cleaning the data.</span>
<span class="sd">    preload : bool</span>
<span class="sd">        If True, read all epochs from disk immediately. If False, epochs will</span>
<span class="sd">        be read on demand.</span>
<span class="sd">    verbose : bool, str, int, or None</span>
<span class="sd">        If not None, override default verbose level (see :func:`mne.verbose`</span>
<span class="sd">        and :ref:`Logging documentation &lt;tut_logging&gt;` for more).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    epochs : instance of Epochs</span>
<span class="sd">        The epochs</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">EpochsFIF</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">proj</span><span class="p">,</span> <span class="n">preload</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_RawContainer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper for a raw data container.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">data_tag</span><span class="p">,</span> <span class="n">event_samps</span><span class="p">,</span> <span class="n">epoch_shape</span><span class="p">,</span>
                 <span class="n">cals</span><span class="p">):</span>  <span class="c1"># noqa: D102</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fid</span> <span class="o">=</span> <span class="n">fid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_tag</span> <span class="o">=</span> <span class="n">data_tag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">event_samps</span> <span class="o">=</span> <span class="n">event_samps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">epoch_shape</span> <span class="o">=</span> <span class="n">epoch_shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cals</span> <span class="o">=</span> <span class="n">cals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proj</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>  <span class="c1"># noqa: D105</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fid</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">EpochsFIF</span><span class="p">(</span><span class="n">BaseEpochs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Epochs read from disk.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str</span>
<span class="sd">        The name of the file, which should end with -epo.fif or -epo.fif.gz.</span>
<span class="sd">    proj : bool | &#39;delayed&#39;</span>
<span class="sd">        Apply SSP projection vectors. If proj is &#39;delayed&#39; and reject is not</span>
<span class="sd">        None the single epochs will be projected before the rejection</span>
<span class="sd">        decision, but used in unprojected state if they are kept.</span>
<span class="sd">        This way deciding which projection vectors are good can be postponed</span>
<span class="sd">        to the evoked stage without resulting in lower epoch counts and</span>
<span class="sd">        without producing results different from early SSP application</span>
<span class="sd">        given comparable parameters. Note that in this case baselining,</span>
<span class="sd">        detrending and temporal decimation will be postponed.</span>
<span class="sd">        If proj is False no projections will be applied which is the</span>
<span class="sd">        recommended value if SSPs are not used for cleaning the data.</span>
<span class="sd">    preload : bool</span>
<span class="sd">        If True, read all epochs from disk immediately. If False, epochs will</span>
<span class="sd">        be read on demand.</span>
<span class="sd">    verbose : bool, str, int, or None</span>
<span class="sd">        If not None, override default verbose level (see :func:`mne.verbose`</span>
<span class="sd">        and :ref:`Logging documentation &lt;tut_logging&gt;` for more). Defaults to</span>
<span class="sd">        raw.verbose.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mne.Epochs</span>
<span class="sd">    mne.epochs.combine_event_ids</span>
<span class="sd">    mne.Epochs.equalize_event_counts</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">preload</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># noqa: D102</span>
        <span class="n">check_fname</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;epochs&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;-epo.fif&#39;</span><span class="p">,</span> <span class="s1">&#39;-epo.fif.gz&#39;</span><span class="p">))</span>
        <span class="n">fnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">fname</span><span class="p">]</span>
        <span class="n">ep_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">raw</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">fnames</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Reading </span><span class="si">%s</span><span class="s1"> ...&#39;</span> <span class="o">%</span> <span class="n">fname</span><span class="p">)</span>
            <span class="n">fid</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">fiff_open</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
            <span class="n">next_fname</span> <span class="o">=</span> <span class="n">_get_next_fname</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">fname</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>
            <span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">data_tag</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">event_id</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> <span class="n">baseline</span><span class="p">,</span>
             <span class="n">selection</span><span class="p">,</span> <span class="n">drop_log</span><span class="p">,</span> <span class="n">epoch_shape</span><span class="p">,</span> <span class="n">cals</span><span class="p">)</span> <span class="o">=</span> \
                <span class="n">_read_one_epoch_file</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">preload</span><span class="p">)</span>
            <span class="c1"># here we ignore missing events, since users should already be</span>
            <span class="c1"># aware of missing events if they have saved data that way</span>
            <span class="n">epoch</span> <span class="o">=</span> <span class="n">BaseEpochs</span><span class="p">(</span>
                <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">event_id</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> <span class="n">baseline</span><span class="p">,</span>
                <span class="n">on_missing</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">selection</span><span class="o">=</span><span class="n">selection</span><span class="p">,</span> <span class="n">drop_log</span><span class="o">=</span><span class="n">drop_log</span><span class="p">,</span>
                <span class="n">proj</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ep_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">epoch</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">preload</span><span class="p">:</span>
                <span class="c1"># store everything we need to index back to the original data</span>
                <span class="n">raw</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_RawContainer</span><span class="p">(</span><span class="n">fiff_open</span><span class="p">(</span><span class="n">fname</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">data_tag</span><span class="p">,</span>
                                         <span class="n">events</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">epoch_shape</span><span class="p">,</span>
                                         <span class="n">cals</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">next_fname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_fname</span><span class="p">)</span>

        <span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">event_id</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> <span class="n">baseline</span><span class="p">,</span> <span class="n">selection</span><span class="p">,</span>
         <span class="n">drop_log</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">_concatenate_epochs</span><span class="p">(</span><span class="n">ep_list</span><span class="p">,</span> <span class="n">with_data</span><span class="o">=</span><span class="n">preload</span><span class="p">)</span>
        <span class="c1"># we need this uniqueness for non-preloaded data to work properly</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">events</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">events</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Event time samples were not unique&#39;</span><span class="p">)</span>

        <span class="c1"># correct the drop log</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">drop_log</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">fnames</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="n">step</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">drop_log</span><span class="p">)</span> <span class="o">//</span> <span class="nb">len</span><span class="p">(</span><span class="n">fnames</span><span class="p">)</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">drop_log</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">offsets</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">other_log</span> <span class="o">=</span> <span class="n">drop_log</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i2</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">drop_log</span><span class="p">,</span> <span class="n">other_log</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="p">[</span><span class="s1">&#39;IGNORED&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">!=</span> <span class="p">[</span><span class="s1">&#39;IGNORED&#39;</span><span class="p">]:</span>
                        <span class="n">drop_log</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span>
        <span class="n">drop_log</span> <span class="o">=</span> <span class="n">drop_log</span><span class="p">[:</span><span class="n">step</span><span class="p">]</span>

        <span class="c1"># call BaseEpochs constructor</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">EpochsFIF</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">event_id</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> <span class="n">baseline</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="n">raw</span><span class="p">,</span>
            <span class="n">proj</span><span class="o">=</span><span class="n">proj</span><span class="p">,</span> <span class="n">preload_at_end</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">on_missing</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span>
            <span class="n">selection</span><span class="o">=</span><span class="n">selection</span><span class="p">,</span> <span class="n">drop_log</span><span class="o">=</span><span class="n">drop_log</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="n">fname</span><span class="p">,</span>
            <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
        <span class="c1"># use the private property instead of drop_bad so that epochs</span>
        <span class="c1"># are not all read from disk for preload=False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bad_dropped</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="nd">@verbose</span>
    <span class="k">def</span> <span class="nf">_get_epoch_from_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Load one epoch from disk.&quot;&quot;&quot;</span>
        <span class="c1"># Find the right file and offset to use</span>
        <span class="n">event_samp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">raw</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">raw</span><span class="o">.</span><span class="n">event_samps</span> <span class="o">==</span> <span class="n">event_samp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">raw</span><span class="o">.</span><span class="n">epoch_shape</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">*</span> <span class="n">size</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># read the correct subset of the data</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Correct epoch could not be found, please &#39;</span>
                               <span class="s1">&#39;contact mne-python developers&#39;</span><span class="p">)</span>
        <span class="c1"># the following is equivalent to this, but faster:</span>
        <span class="c1">#</span>
        <span class="c1"># &gt;&gt;&gt; data = read_tag(raw.fid, raw.data_tag.pos).data.astype(float)</span>
        <span class="c1"># &gt;&gt;&gt; data *= raw.cals[np.newaxis, :, :]</span>
        <span class="c1"># &gt;&gt;&gt; data = data[idx]</span>
        <span class="c1">#</span>
        <span class="c1"># Eventually this could be refactored in io/tag.py if other functions</span>
        <span class="c1"># could make use of it</span>

        <span class="n">raw</span><span class="o">.</span><span class="n">fid</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">raw</span><span class="o">.</span><span class="n">data_tag</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># 16 = Tag header</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">raw</span><span class="o">.</span><span class="n">fid</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="s1">&#39;&gt;f4&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">raw</span><span class="o">.</span><span class="n">epoch_shape</span>
        <span class="n">data</span> <span class="o">*=</span> <span class="n">raw</span><span class="o">.</span><span class="n">cals</span>
        <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">bootstrap</span><span class="p">(</span><span class="n">epochs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute epochs selected by bootstrapping.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    epochs : Epochs instance</span>
<span class="sd">        epochs data to be bootstrapped</span>
<span class="sd">    random_state : None | int | np.random.RandomState</span>
<span class="sd">        To specify the random generator state</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    epochs : Epochs instance</span>
<span class="sd">        The bootstrap samples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">epochs</span><span class="o">.</span><span class="n">preload</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Modifying data of epochs is only supported &#39;</span>
                           <span class="s1">&#39;when preloading is used. Use preload=True &#39;</span>
                           <span class="s1">&#39;in the constructor.&#39;</span><span class="p">)</span>

    <span class="n">rng</span> <span class="o">=</span> <span class="n">check_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
    <span class="n">epochs_bootstrap</span> <span class="o">=</span> <span class="n">epochs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">n_events</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">epochs_bootstrap</span><span class="o">.</span><span class="n">events</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_events</span><span class="p">,</span> <span class="n">n_events</span><span class="p">)</span>
    <span class="n">epochs_bootstrap</span> <span class="o">=</span> <span class="n">epochs_bootstrap</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">epochs_bootstrap</span>


<span class="k">def</span> <span class="nf">_check_merge_epochs</span><span class="p">(</span><span class="n">epochs_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Aux function.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">event_id</span><span class="o">.</span><span class="n">items</span><span class="p">())</span> <span class="k">for</span> <span class="n">epochs</span> <span class="ow">in</span> <span class="n">epochs_list</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Epochs with unequal values for event_id&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">tmin</span> <span class="k">for</span> <span class="n">epochs</span> <span class="ow">in</span> <span class="n">epochs_list</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Epochs with unequal values for tmin&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">tmax</span> <span class="k">for</span> <span class="n">epochs</span> <span class="ow">in</span> <span class="n">epochs_list</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Epochs with unequal values for tmax&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">baseline</span> <span class="k">for</span> <span class="n">epochs</span> <span class="ow">in</span> <span class="n">epochs_list</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Epochs with unequal values for baseline&quot;</span><span class="p">)</span>


<span class="nd">@verbose</span>
<span class="k">def</span> <span class="nf">add_channels_epochs</span><span class="p">(</span><span class="n">epochs_list</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Concatenate channels, info and data from two Epochs objects.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    epochs_list : list of Epochs</span>
<span class="sd">        Epochs object to concatenate.</span>
<span class="sd">    verbose : bool, str, int, or None</span>
<span class="sd">        If not None, override default verbose level (see :func:`mne.verbose`</span>
<span class="sd">        and :ref:`Logging documentation &lt;tut_logging&gt;` for more). Defaults to</span>
<span class="sd">        True if any of the input epochs have verbose=True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    epochs : instance of Epochs</span>
<span class="sd">        Concatenated epochs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">preload</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">epochs_list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All epochs must be preloaded.&#39;</span><span class="p">)</span>

    <span class="n">info</span> <span class="o">=</span> <span class="n">_merge_info</span><span class="p">([</span><span class="n">epochs</span><span class="o">.</span><span class="n">info</span> <span class="k">for</span> <span class="n">epochs</span> <span class="ow">in</span> <span class="n">epochs_list</span><span class="p">])</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">epochs</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span> <span class="k">for</span> <span class="n">epochs</span> <span class="ow">in</span> <span class="n">epochs_list</span><span class="p">]</span>
    <span class="n">_check_merge_epochs</span><span class="p">(</span><span class="n">epochs_list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;all epochs must be of the same length&#39;</span><span class="p">)</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;chs&#39;</span><span class="p">])</span> <span class="o">!=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">err</span> <span class="o">=</span> <span class="s2">&quot;Data shape does not match channel number in measurement info&quot;</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>

    <span class="n">events</span> <span class="o">=</span> <span class="n">epochs_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">all_same</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">epochs</span><span class="o">.</span><span class="n">events</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">epochs</span> <span class="ow">in</span> <span class="n">epochs_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">all_same</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Events must be the same.&#39;</span><span class="p">)</span>

    <span class="n">proj</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">proj</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">epochs_list</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">verbose</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">verbose</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">epochs_list</span><span class="p">)</span>

    <span class="n">epochs</span> <span class="o">=</span> <span class="n">epochs_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">epochs</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">info</span>
    <span class="n">epochs</span><span class="o">.</span><span class="n">picks</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">epochs</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
    <span class="n">epochs</span><span class="o">.</span><span class="n">events</span> <span class="o">=</span> <span class="n">events</span>
    <span class="n">epochs</span><span class="o">.</span><span class="n">preload</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">epochs</span><span class="o">.</span><span class="n">_bad_dropped</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">epochs</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">data</span>
    <span class="n">epochs</span><span class="o">.</span><span class="n">_projector</span><span class="p">,</span> <span class="n">epochs</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">setup_proj</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span>
                                                <span class="n">activate</span><span class="o">=</span><span class="n">proj</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">epochs</span>


<span class="k">def</span> <span class="nf">_compare_epochs_infos</span><span class="p">(</span><span class="n">info1</span><span class="p">,</span> <span class="n">info2</span><span class="p">,</span> <span class="n">ind</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compare infos.&quot;&quot;&quot;</span>
    <span class="n">info1</span><span class="o">.</span><span class="n">_check_consistency</span><span class="p">()</span>
    <span class="n">info2</span><span class="o">.</span><span class="n">_check_consistency</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">info1</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">info2</span><span class="p">[</span><span class="s1">&#39;nchan&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;epochs[</span><span class="si">%d</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">info</span><span class="se">\&#39;</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">nchan</span><span class="se">\&#39;</span><span class="s1">] must match&#39;</span> <span class="o">%</span> <span class="n">ind</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">info1</span><span class="p">[</span><span class="s1">&#39;bads&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">info2</span><span class="p">[</span><span class="s1">&#39;bads&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;epochs[</span><span class="si">%d</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">info</span><span class="se">\&#39;</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">bads</span><span class="se">\&#39;</span><span class="s1">] must match&#39;</span> <span class="o">%</span> <span class="n">ind</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">info1</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">info2</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;epochs[</span><span class="si">%d</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">info</span><span class="se">\&#39;</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">sfreq</span><span class="se">\&#39;</span><span class="s1">] must match&#39;</span> <span class="o">%</span> <span class="n">ind</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">info1</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">set</span><span class="p">(</span><span class="n">info2</span><span class="p">[</span><span class="s1">&#39;ch_names&#39;</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;epochs[</span><span class="si">%d</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">info</span><span class="se">\&#39;</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">ch_names</span><span class="se">\&#39;</span><span class="s1">] must match&#39;</span> <span class="o">%</span> <span class="n">ind</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">info2</span><span class="p">[</span><span class="s1">&#39;projs&#39;</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">info1</span><span class="p">[</span><span class="s1">&#39;projs&#39;</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;SSP projectors in epochs files must be the same&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="n">_proj_equal</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span> <span class="k">for</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span>
           <span class="nb">zip</span><span class="p">(</span><span class="n">info2</span><span class="p">[</span><span class="s1">&#39;projs&#39;</span><span class="p">],</span> <span class="n">info1</span><span class="p">[</span><span class="s1">&#39;projs&#39;</span><span class="p">])):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;SSP projectors in epochs files must be the same&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">info1</span><span class="p">[</span><span class="s1">&#39;dev_head_t&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="n">info2</span><span class="p">[</span><span class="s1">&#39;dev_head_t&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> \
            <span class="p">(</span><span class="n">info1</span><span class="p">[</span><span class="s1">&#39;dev_head_t&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span>
             <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">info1</span><span class="p">[</span><span class="s1">&#39;dev_head_t&#39;</span><span class="p">][</span><span class="s1">&#39;trans&#39;</span><span class="p">],</span>
                         <span class="n">info2</span><span class="p">[</span><span class="s1">&#39;dev_head_t&#39;</span><span class="p">][</span><span class="s1">&#39;trans&#39;</span><span class="p">],</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;epochs[</span><span class="si">%d</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">info</span><span class="se">\&#39;</span><span class="s1">][</span><span class="se">\&#39;</span><span class="s1">dev_head_t</span><span class="se">\&#39;</span><span class="s1">] must match. &#39;</span>
                         <span class="s1">&#39;The epochs probably come from different runs, and &#39;</span>
                         <span class="s1">&#39;are therefore associated with different head &#39;</span>
                         <span class="s1">&#39;positions. Manually change info[</span><span class="se">\&#39;</span><span class="s1">dev_head_t</span><span class="se">\&#39;</span><span class="s1">] to &#39;</span>
                         <span class="s1">&#39;avoid this message but beware that this means the &#39;</span>
                         <span class="s1">&#39;MEG sensors will not be properly spatially aligned. &#39;</span>
                         <span class="s1">&#39;See mne.preprocessing.maxwell_filter to realign the &#39;</span>
                         <span class="s1">&#39;runs to a common head position.&#39;</span> <span class="o">%</span> <span class="n">ind</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_concatenate_epochs</span><span class="p">(</span><span class="n">epochs_list</span><span class="p">,</span> <span class="n">with_data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Auxiliary function for concatenating epochs.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">epochs_list</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;epochs_list must be a list or tuple, got </span><span class="si">%s</span><span class="s1">&#39;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">epochs_list</span><span class="p">),))</span>
    <span class="k">for</span> <span class="n">ei</span><span class="p">,</span> <span class="n">epochs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">epochs_list</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">epochs</span><span class="p">,</span> <span class="n">BaseEpochs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;epochs_list[</span><span class="si">%d</span><span class="s1">] must be an instance of Epochs, &#39;</span>
                            <span class="s1">&#39;got </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">ei</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">epochs</span><span class="p">)))</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">epochs_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">out</span><span class="o">.</span><span class="n">get_data</span><span class="p">()]</span> <span class="k">if</span> <span class="n">with_data</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="n">events</span> <span class="o">=</span> <span class="p">[</span><span class="n">out</span><span class="o">.</span><span class="n">events</span><span class="p">]</span>
    <span class="n">baseline</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">baseline</span><span class="p">,</span> <span class="n">out</span><span class="o">.</span><span class="n">tmin</span><span class="p">,</span> <span class="n">out</span><span class="o">.</span><span class="n">tmax</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>
    <span class="n">verbose</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">verbose</span>
    <span class="n">drop_log</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">drop_log</span><span class="p">)</span>
    <span class="n">event_id</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">event_id</span><span class="p">)</span>
    <span class="n">selection</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">selection</span>
    <span class="c1"># offset is the last epoch + tmax + 10 second</span>
    <span class="n">events_offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">events</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
                     <span class="nb">int</span><span class="p">((</span><span class="mi">10</span> <span class="o">+</span> <span class="n">tmax</span><span class="p">)</span> <span class="o">*</span> <span class="n">epochs</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]))</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">epochs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">epochs_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="n">_compare_epochs_infos</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">ii</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">times</span><span class="p">,</span> <span class="n">epochs_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">times</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Epochs must have same times&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">epochs</span><span class="o">.</span><span class="n">baseline</span> <span class="o">!=</span> <span class="n">baseline</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Baseline must be same for all epochs&#39;</span><span class="p">)</span>

        <span class="c1"># compare event_id</span>
        <span class="n">common_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">event_id</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">event_id</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">common_keys</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">event_id</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">==</span> <span class="n">epochs</span><span class="o">.</span><span class="n">event_id</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;event_id values must be the same for identical keys &#39;</span>
                       <span class="s1">&#39;for all concatenated epochs. Key &quot;</span><span class="si">{}</span><span class="s1">&quot; maps to </span><span class="si">{}</span><span class="s1"> in &#39;</span>
                       <span class="s1">&#39;some epochs and to </span><span class="si">{}</span><span class="s1"> in others.&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">event_id</span><span class="p">[</span><span class="n">key</span><span class="p">],</span>
                                            <span class="n">epochs</span><span class="o">.</span><span class="n">event_id</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">with_data</span><span class="p">:</span>
            <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">get_data</span><span class="p">())</span>
        <span class="n">evs</span> <span class="o">=</span> <span class="n">epochs</span><span class="o">.</span><span class="n">events</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># add offset</span>
        <span class="n">evs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">events_offset</span>
        <span class="c1"># Update offset for the next iteration.</span>
        <span class="c1"># offset is the last epoch + tmax + 10 second</span>
        <span class="n">events_offset</span> <span class="o">+=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">evs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">+</span>
                          <span class="nb">int</span><span class="p">((</span><span class="mi">10</span> <span class="o">+</span> <span class="n">tmax</span><span class="p">)</span> <span class="o">*</span> <span class="n">epochs</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]))</span>
        <span class="n">events</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">evs</span><span class="p">)</span>
        <span class="n">selection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">selection</span><span class="p">,</span> <span class="n">epochs</span><span class="o">.</span><span class="n">selection</span><span class="p">))</span>
        <span class="n">drop_log</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">drop_log</span><span class="p">)</span>
        <span class="n">event_id</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">event_id</span><span class="p">)</span>
    <span class="n">events</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">events</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">with_data</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">event_id</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> <span class="n">baseline</span><span class="p">,</span> <span class="n">selection</span><span class="p">,</span>
            <span class="n">drop_log</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_finish_concat</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">event_id</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> <span class="n">baseline</span><span class="p">,</span>
                   <span class="n">selection</span><span class="p">,</span> <span class="n">drop_log</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Finish concatenation for epochs not read from disk.&quot;&quot;&quot;</span>
    <span class="n">selection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">drop_log</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">BaseEpochs</span><span class="p">(</span>
        <span class="n">info</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">event_id</span><span class="p">,</span> <span class="n">tmin</span><span class="p">,</span> <span class="n">tmax</span><span class="p">,</span> <span class="n">baseline</span><span class="o">=</span><span class="n">baseline</span><span class="p">,</span>
        <span class="n">selection</span><span class="o">=</span><span class="n">selection</span><span class="p">,</span> <span class="n">drop_log</span><span class="o">=</span><span class="n">drop_log</span><span class="p">,</span> <span class="n">proj</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">on_missing</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="n">out</span><span class="o">.</span><span class="n">drop_bad</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">concatenate_epochs</span><span class="p">(</span><span class="n">epochs_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Concatenate a list of epochs into one epochs object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    epochs_list : list</span>
<span class="sd">        list of Epochs instances to concatenate (in order).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    epochs : instance of Epochs</span>
<span class="sd">        The result of the concatenation (first Epochs instance passed in).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. versionadded:: 0.9.0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_finish_concat</span><span class="p">(</span><span class="o">*</span><span class="n">_concatenate_epochs</span><span class="p">(</span><span class="n">epochs_list</span><span class="p">))</span>


<span class="nd">@verbose</span>
<span class="k">def</span> <span class="nf">average_movements</span><span class="p">(</span><span class="n">epochs</span><span class="p">,</span> <span class="n">head_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">orig_sfreq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">picks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">weight_all</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">int_order</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">ext_order</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                      <span class="n">destination</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ignore_ref</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_mapping</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">mag_scale</span><span class="o">=</span><span class="mf">100.</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">u</span><span class="sd">&quot;&quot;&quot;Average data using Maxwell filtering, transforming using head positions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    epochs : instance of Epochs</span>
<span class="sd">        The epochs to operate on.</span>
<span class="sd">    head_pos : array | tuple | None</span>
<span class="sd">        The array should be of shape ``(N, 10)``, holding the position</span>
<span class="sd">        parameters as returned by e.g. `read_head_pos`. For backward</span>
<span class="sd">        compatibility, this can also be a tuple of ``(trans, rot t)``</span>
<span class="sd">        as returned by `head_pos_to_trans_rot_t`.</span>
<span class="sd">    orig_sfreq : float | None</span>
<span class="sd">        The original sample frequency of the data (that matches the</span>
<span class="sd">        event sample numbers in ``epochs.events``). Can be ``None``</span>
<span class="sd">        if data have not been decimated or resampled.</span>
<span class="sd">    picks : array-like of int | None</span>
<span class="sd">        If None only MEG, EEG, SEEG, ECoG, and fNIRS channels are kept</span>
<span class="sd">        otherwise the channels indices in picks are kept.</span>
<span class="sd">    origin : array-like, shape (3,) | str</span>
<span class="sd">        Origin of internal and external multipolar moment space in head</span>
<span class="sd">        coords and in meters. The default is ``&#39;auto&#39;``, which means</span>
<span class="sd">        a head-digitization-based origin fit.</span>
<span class="sd">    weight_all : bool</span>
<span class="sd">        If True, all channels are weighted by the SSS basis weights.</span>
<span class="sd">        If False, only MEG channels are weighted, other channels</span>
<span class="sd">        receive uniform weight per epoch.</span>
<span class="sd">    int_order : int</span>
<span class="sd">        Order of internal component of spherical expansion.</span>
<span class="sd">    ext_order : int</span>
<span class="sd">        Order of external component of spherical expansion.</span>
<span class="sd">    regularize : str | None</span>
<span class="sd">        Basis regularization type, must be &quot;in&quot; or None.</span>
<span class="sd">        See :func:`mne.preprocessing.maxwell_filter` for details.</span>
<span class="sd">        Regularization is chosen based only on the destination position.</span>
<span class="sd">    destination : str | array-like, shape (3,) | None</span>
<span class="sd">        The destination location for the head. Can be ``None``, which</span>
<span class="sd">        will not change the head position, or a string path to a FIF file</span>
<span class="sd">        containing a MEG device&lt;-&gt;head transformation, or a 3-element array</span>
<span class="sd">        giving the coordinates to translate to (with no rotations).</span>
<span class="sd">        For example, ``destination=(0, 0, 0.04)`` would translate the bases</span>
<span class="sd">        as ``--trans default`` would in MaxFilter (i.e., to the default</span>
<span class="sd">        head location).</span>

<span class="sd">        .. versionadded:: 0.12</span>

<span class="sd">    ignore_ref : bool</span>
<span class="sd">        If True, do not include reference channels in compensation. This</span>
<span class="sd">        option should be True for KIT files, since Maxwell filtering</span>
<span class="sd">        with reference channels is not currently supported.</span>
<span class="sd">    return_mapping : bool</span>
<span class="sd">        If True, return the mapping matrix.</span>
<span class="sd">    mag_scale : float | str</span>
<span class="sd">        The magenetometer scale-factor used to bring the magnetometers</span>
<span class="sd">        to approximately the same order of magnitude as the gradiometers</span>
<span class="sd">        (default 100.), as they have different units (T vs T/m).</span>
<span class="sd">        Can be ``&#39;auto&#39;`` to use the reciprocal of the physical distance</span>
<span class="sd">        between the gradiometer pickup loops (e.g., 0.0168 m yields</span>
<span class="sd">        59.5 for VectorView).</span>

<span class="sd">        .. versionadded:: 0.13</span>

<span class="sd">    verbose : bool, str, int, or None</span>
<span class="sd">        If not None, override default verbose level (see :func:`mne.verbose`</span>
<span class="sd">        and :ref:`Logging documentation &lt;tut_logging&gt;` for more).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    evoked : instance of Evoked</span>
<span class="sd">        The averaged epochs.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mne.preprocessing.maxwell_filter</span>
<span class="sd">    mne.chpi.read_head_pos</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The Maxwell filtering version of this algorithm is described in [1]_,</span>
<span class="sd">    in section V.B &quot;Virtual signals and movement correction&quot;, equations</span>
<span class="sd">    40-44. For additional validation, see [2]_.</span>

<span class="sd">    Regularization has not been added because in testing it appears to</span>
<span class="sd">    decrease dipole localization accuracy relative to using all components.</span>
<span class="sd">    Fine calibration and cross-talk cancellation, however, could be added</span>
<span class="sd">    to this algorithm based on user demand.</span>

<span class="sd">    .. versionadded:: 0.11</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Taulu S. and Kajola M. &quot;Presentation of electromagnetic</span>
<span class="sd">           multichannel data: The signal space separation method,&quot;</span>
<span class="sd">           Journal of Applied Physics, vol. 97, pp. 124905 1-10, 2005.</span>

<span class="sd">    .. [2] Wehner DT, Hmlinen MS, Mody M, Ahlfors SP. &quot;Head movements</span>
<span class="sd">           of children in MEG: Quantification, effects on source</span>
<span class="sd">           estimation, and compensation. NeuroImage 40:541550, 2008.</span>
<span class="sd">    &quot;&quot;&quot;</span>  <span class="c1"># noqa: E501</span>
    <span class="kn">from</span> <span class="nn">.preprocessing.maxwell</span> <span class="k">import</span> <span class="p">(</span><span class="n">_trans_sss_basis</span><span class="p">,</span> <span class="n">_reset_meg_bads</span><span class="p">,</span>
                                        <span class="n">_check_usable</span><span class="p">,</span> <span class="n">_col_norm_pinv</span><span class="p">,</span>
                                        <span class="n">_get_n_moments</span><span class="p">,</span> <span class="n">_get_mf_picks</span><span class="p">,</span>
                                        <span class="n">_prep_mf_coils</span><span class="p">,</span> <span class="n">_check_destination</span><span class="p">,</span>
                                        <span class="n">_remove_meg_projs</span><span class="p">,</span> <span class="n">_get_coil_scale</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">head_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;head_pos must be provided and cannot be None&#39;</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">.chpi</span> <span class="k">import</span> <span class="n">head_pos_to_trans_rot_t</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">epochs</span><span class="p">,</span> <span class="n">BaseEpochs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;epochs must be an instance of Epochs, not </span><span class="si">%s</span><span class="s1">&#39;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">epochs</span><span class="p">),))</span>
    <span class="n">orig_sfreq</span> <span class="o">=</span> <span class="n">epochs</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;sfreq&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">orig_sfreq</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">orig_sfreq</span>
    <span class="n">orig_sfreq</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">orig_sfreq</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">head_pos</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">head_pos</span> <span class="o">=</span> <span class="n">head_pos_to_trans_rot_t</span><span class="p">(</span><span class="n">head_pos</span><span class="p">)</span>
    <span class="n">trn</span><span class="p">,</span> <span class="n">rot</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">head_pos</span>
    <span class="k">del</span> <span class="n">head_pos</span>
    <span class="n">_check_usable</span><span class="p">(</span><span class="n">epochs</span><span class="p">)</span>
    <span class="n">origin</span> <span class="o">=</span> <span class="n">_check_origin</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">epochs</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s1">&#39;head&#39;</span><span class="p">)</span>
    <span class="n">recon_trans</span> <span class="o">=</span> <span class="n">_check_destination</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">epochs</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Aligning and averaging up to </span><span class="si">%s</span><span class="s1"> epochs&#39;</span>
                <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">events</span><span class="p">)))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">events</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">events</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])):</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Epochs must have monotonically increasing events&#39;</span><span class="p">)</span>
    <span class="n">meg_picks</span><span class="p">,</span> <span class="n">mag_picks</span><span class="p">,</span> <span class="n">grad_picks</span><span class="p">,</span> <span class="n">good_picks</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> \
        <span class="n">_get_mf_picks</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">int_order</span><span class="p">,</span> <span class="n">ext_order</span><span class="p">,</span> <span class="n">ignore_ref</span><span class="p">)</span>
    <span class="n">coil_scale</span><span class="p">,</span> <span class="n">mag_scale</span> <span class="o">=</span> <span class="n">_get_coil_scale</span><span class="p">(</span>
        <span class="n">meg_picks</span><span class="p">,</span> <span class="n">mag_picks</span><span class="p">,</span> <span class="n">grad_picks</span><span class="p">,</span> <span class="n">mag_scale</span><span class="p">,</span> <span class="n">epochs</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>
    <span class="n">n_channels</span><span class="p">,</span> <span class="n">n_times</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">ch_names</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">times</span><span class="p">)</span>
    <span class="n">other_picks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_channels</span><span class="p">),</span> <span class="n">meg_picks</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_channels</span><span class="p">,</span> <span class="n">n_times</span><span class="p">))</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># keep only MEG w/bad channels marked in &quot;info_from&quot;</span>
    <span class="n">info_from</span> <span class="o">=</span> <span class="n">pick_info</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">good_picks</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">all_coils_recon</span> <span class="o">=</span> <span class="n">_prep_mf_coils</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="n">ignore_ref</span><span class="o">=</span><span class="n">ignore_ref</span><span class="p">)</span>
    <span class="n">all_coils</span> <span class="o">=</span> <span class="n">_prep_mf_coils</span><span class="p">(</span><span class="n">info_from</span><span class="p">,</span> <span class="n">ignore_ref</span><span class="o">=</span><span class="n">ignore_ref</span><span class="p">)</span>
    <span class="c1"># remove MEG bads in &quot;to&quot; info</span>
    <span class="n">info_to</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">epochs</span><span class="o">.</span><span class="n">info</span><span class="p">)</span>
    <span class="n">_reset_meg_bads</span><span class="p">(</span><span class="n">info_to</span><span class="p">)</span>
    <span class="c1"># set up variables</span>
    <span class="n">w_sum</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">n_in</span><span class="p">,</span> <span class="n">n_out</span> <span class="o">=</span> <span class="n">_get_n_moments</span><span class="p">([</span><span class="n">int_order</span><span class="p">,</span> <span class="n">ext_order</span><span class="p">])</span>
    <span class="n">S_decomp</span> <span class="o">=</span> <span class="mf">0.</span>  <span class="c1"># this will end up being a weighted average</span>
    <span class="n">last_trans</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">decomp_coil_scale</span> <span class="o">=</span> <span class="n">coil_scale</span><span class="p">[</span><span class="n">good_picks</span><span class="p">]</span>
    <span class="n">exp</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">int_order</span><span class="o">=</span><span class="n">int_order</span><span class="p">,</span> <span class="n">ext_order</span><span class="o">=</span><span class="n">ext_order</span><span class="p">,</span> <span class="n">head_frame</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
               <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ei</span><span class="p">,</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">epochs</span><span class="p">):</span>
        <span class="n">event_time</span> <span class="o">=</span> <span class="n">epochs</span><span class="o">.</span><span class="n">events</span><span class="p">[</span><span class="n">epochs</span><span class="o">.</span><span class="n">_current</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">orig_sfreq</span>
        <span class="n">use_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">t</span> <span class="o">&lt;=</span> <span class="n">event_time</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">use_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="n">epochs</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;dev_head_t&#39;</span><span class="p">][</span><span class="s1">&#39;trans&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">use_idx</span> <span class="o">=</span> <span class="n">use_idx</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">rot</span><span class="p">[</span><span class="n">use_idx</span><span class="p">],</span> <span class="n">trn</span><span class="p">[[</span><span class="n">use_idx</span><span class="p">]]</span><span class="o">.</span><span class="n">T</span><span class="p">]),</span>
                               <span class="p">[[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]]])</span>
        <span class="n">loc_str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%0.1f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">tr</span> <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="p">(</span><span class="n">trans</span><span class="p">[:</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">last_trans</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">last_trans</span><span class="p">,</span> <span class="n">trans</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;    Processing epoch </span><span class="si">%s</span><span class="s1"> (device location: </span><span class="si">%s</span><span class="s1"> mm)&#39;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">ei</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">loc_str</span><span class="p">))</span>
            <span class="n">reuse</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">last_trans</span> <span class="o">=</span> <span class="n">trans</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;    Processing epoch </span><span class="si">%s</span><span class="s1"> (device location: same)&#39;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="n">ei</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,))</span>
            <span class="n">reuse</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">epoch</span> <span class="o">=</span> <span class="n">epoch</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># because we operate inplace</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">reuse</span><span class="p">:</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">_trans_sss_basis</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">all_coils</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span>
                                 <span class="n">coil_scale</span><span class="o">=</span><span class="n">decomp_coil_scale</span><span class="p">)</span>
            <span class="c1"># Get the weight from the un-regularized version</span>
            <span class="n">weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">S</span> <span class="o">*</span> <span class="n">S</span><span class="p">))</span>  <span class="c1"># frobenius norm (eq. 44)</span>
            <span class="c1"># XXX Eventually we could do cross-talk and fine-cal here</span>
            <span class="n">S</span> <span class="o">*=</span> <span class="n">weight</span>
        <span class="n">S_decomp</span> <span class="o">+=</span> <span class="n">S</span>  <span class="c1"># eq. 41</span>
        <span class="n">epoch</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">weight_all</span> <span class="k">else</span> <span class="n">meg_picks</span><span class="p">]</span> <span class="o">*=</span> <span class="n">weight</span>
        <span class="n">data</span> <span class="o">+=</span> <span class="n">epoch</span>  <span class="c1"># eq. 42</span>
        <span class="n">w_sum</span> <span class="o">+=</span> <span class="n">weight</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">del</span> <span class="n">info_from</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span><span class="p">[</span><span class="n">meg_picks</span><span class="p">]</span> <span class="o">/=</span> <span class="n">w_sum</span>
        <span class="n">data</span><span class="p">[</span><span class="n">other_picks</span><span class="p">]</span> <span class="o">/=</span> <span class="n">w_sum</span> <span class="k">if</span> <span class="n">weight_all</span> <span class="k">else</span> <span class="n">count</span>
        <span class="c1"># Finalize weighted average decomp matrix</span>
        <span class="n">S_decomp</span> <span class="o">/=</span> <span class="n">w_sum</span>
        <span class="c1"># Get recon matrix</span>
        <span class="c1"># (We would need to include external here for regularization to work)</span>
        <span class="n">exp</span><span class="p">[</span><span class="s1">&#39;ext_order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">S_recon</span> <span class="o">=</span> <span class="n">_trans_sss_basis</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">all_coils_recon</span><span class="p">,</span> <span class="n">recon_trans</span><span class="p">)</span>
        <span class="n">exp</span><span class="p">[</span><span class="s1">&#39;ext_order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ext_order</span>
        <span class="c1"># We could determine regularization on basis of destination basis</span>
        <span class="c1"># matrix, restricted to good channels, as regularizing individual</span>
        <span class="c1"># matrices within the loop above does not seem to work. But in</span>
        <span class="c1"># testing this seemed to decrease localization quality in most cases,</span>
        <span class="c1"># so we do not provide the option here.</span>
        <span class="n">S_recon</span> <span class="o">/=</span> <span class="n">coil_scale</span>
        <span class="c1"># Invert</span>
        <span class="n">pS_ave</span> <span class="o">=</span> <span class="n">_col_norm_pinv</span><span class="p">(</span><span class="n">S_decomp</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:</span><span class="n">n_in</span><span class="p">]</span>
        <span class="n">pS_ave</span> <span class="o">*=</span> <span class="n">decomp_coil_scale</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># Get mapping matrix</span>
        <span class="n">mapping</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">S_recon</span><span class="p">,</span> <span class="n">pS_ave</span><span class="p">)</span>
        <span class="c1"># Apply mapping</span>
        <span class="n">data</span><span class="p">[</span><span class="n">meg_picks</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">good_picks</span><span class="p">])</span>
    <span class="n">info_to</span><span class="p">[</span><span class="s1">&#39;dev_head_t&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">recon_trans</span>  <span class="c1"># set the reconstruction transform</span>
    <span class="n">evoked</span> <span class="o">=</span> <span class="n">epochs</span><span class="o">.</span><span class="n">_evoked_from_epoch_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">info_to</span><span class="p">,</span> <span class="n">picks</span><span class="p">,</span>
                                            <span class="n">n_events</span><span class="o">=</span><span class="n">count</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;average&#39;</span><span class="p">,</span>
                                            <span class="n">comment</span><span class="o">=</span><span class="n">epochs</span><span class="o">.</span><span class="n">_name</span><span class="p">)</span>
    <span class="n">_remove_meg_projs</span><span class="p">(</span><span class="n">evoked</span><span class="p">)</span>  <span class="c1"># remove MEG projectors, they won&#39;t apply now</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Created Evoked dataset from </span><span class="si">%s</span><span class="s1"> epochs&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">count</span><span class="p">,))</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">evoked</span><span class="p">,</span> <span class="n">mapping</span><span class="p">)</span> <span class="k">if</span> <span class="n">return_mapping</span> <span class="k">else</span> <span class="n">evoked</span>


<span class="nd">@verbose</span>
<span class="k">def</span> <span class="nf">_segment_raw</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="n">segment_length</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Divide continuous raw data into equal-sized consecutive epochs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    raw : instance of Raw</span>
<span class="sd">        Raw data to divide into segments.</span>
<span class="sd">    segment_length : float</span>
<span class="sd">        Length of each segment in seconds. Defaults to 1.</span>
<span class="sd">    verbose: bool</span>
<span class="sd">        Whether to report what is being done by printing text.</span>
<span class="sd">    **kwargs</span>
<span class="sd">        Any additional keyword arguments are passed to ``Epochs`` constructor.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    epochs : instance of ``Epochs``</span>
<span class="sd">        Segmented data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">events</span> <span class="o">=</span> <span class="n">make_fixed_length_events</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="n">segment_length</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Epochs</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="n">events</span><span class="p">,</span> <span class="n">event_id</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tmin</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">tmax</span><span class="o">=</span><span class="n">segment_length</span><span class="p">,</span>
                  <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">baseline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2017, Jan Freyberg.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.2.<br/>
    </p>
  </div>
</footer>
  </body>
</html>